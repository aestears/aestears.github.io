<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="plantTracker">
<title>Using the `plantTracker` `trackSpp()` function • plantTracker</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Using the `plantTracker` `trackSpp()` function">
<meta property="og:description" content="plantTracker">
<meta property="og:image" content="http://www.astearsresearch.com/package/plantTracker/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">plantTracker</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/Suggested_plantTracker_Workflow.html">Suggested `plantTracker` Workflow</a>
    <a class="dropdown-item" href="../articles/Using_the_plantTracker_trackSpp_function.html">Using the `plantTracker` `trackSpp()` function</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/aestears/plantTracker/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Using the `plantTracker` `trackSpp()` function</h1>
            
            <h4 data-toc-skip class="date">17 February 2022</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/aestears/plantTracker/blob/HEAD/vignettes/Using_the_plantTracker_trackSpp_function.Rmd" class="external-link"><code>vignettes/Using_the_plantTracker_trackSpp_function.Rmd</code></a></small>
      <div class="d-none name"><code>Using_the_plantTracker_trackSpp_function.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette gives detailed information about the
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> function, the main “workhorse” function in the
<code>plantTracker</code> R package. <code><a href="../reference/trackSpp.html">trackSpp()</a></code> transforms
a data set of annual maps of plant occurrence into a demographic data
set. To accomplish this, the function compares maps across sampling
years and assigns unique identifiers (“trackIDs”) to plants that overlap
from year to year. Plants with the same trackID are assumed to be the
same individual. These trackIDs are then used to assign survival,
growth, recruit status, and age to each individual plant in each
year.</p>
<p>This process is complex and requires certain assumptions, so the
following pages will explain and illustrate the logic of each of these
steps. We recommend you read through this vignette before using
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> in order to fully understand the assumptions
inherent to the function, and to make sure that you are adjusting the
user-specified arguments correctly.</p>
</div>
<div class="section level2">
<h2 id="input-data">
<em>1</em> Input data<a class="anchor" aria-label="anchor" href="#input-data"></a>
</h2>
<p>The required inputs to the <code><a href="../reference/trackSpp.html">trackSpp()</a></code> function are
explained in detail in <a href="Suggested_plantTracker_Workflow.html">Suggested
<code>plantTracker</code> Workflow</a>, Parts 1.1, 1.2, and 2, as well
as the “help” file for this function (which you can access by typing
<code><a href="../reference/trackSpp.html">?trackSpp</a></code> in the R console). However, I’ll include a short
description of the arguments here:</p>
<table style="width:98%;" class="table">
<colgroup>
<col width="18%">
<col width="50%">
<col width="12%">
<col width="16%">
</colgroup>
<thead><tr class="header">
<th>
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> argument</th>
<th>description</th>
<th>required?</th>
<th>default?</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>dat</td>
<td>An sf data frame in which each row has spatial data for an
individual observation in one year.</td>
<td>Yes</td>
<td>N/A</td>
</tr>
<tr class="even">
<td>inv</td>
<td>A named list in which the name of each element of the list is a
quadrat name in <code>dat</code>, and the contents of that list element
is a numeric vector of all of the years in which that quadrat was
actually sampled (not just the years that have data in
<code>dat</code>!)</td>
<td>Yes</td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>dorm</td>
<td>A single value greater than or equal to 0 indicating the number of
years these species are allowed to go dormant. <strong>OR</strong> a
data frame with a row for each species in <code>dat</code>, species
names in the “Species” column and a dormancy value in the “dorm”
column.</td>
<td>Yes</td>
<td>N/A</td>
</tr>
<tr class="even">
<td>buff</td>
<td>A single value greater than or equal equal to zero, indicating how
far a far a polygon can move from year <code>i</code> to year
<code>i+1</code> and still be considered the same individual.
<strong>OR</strong> a data frame with a row for each species present in
<code>dat</code>, species names in the “Species” column, and a
<code>buff</code> value in the “buff” column.</td>
<td>Yes</td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>clonal</td>
<td>A logical value (TRUE or FALSE) indicating whether a species is
allowed to be clonal or not. <strong>OR</strong> a data frame with a row
for each species in <code>dat</code>, species names in the “Species”
column, and a <code>clonal</code> value in the “clonal” column.</td>
<td>Yes</td>
<td>N/A</td>
</tr>
<tr class="even">
<td>buffGenet</td>
<td>A single value greater than or equal to zero indicating how close
polygons must be to one another in the same year to be grouped as a
genet. <strong>OR</strong> a data frame with a row for each species in
<code>dat</code>, species names in the “Species” column, and a
<code>buffGenet</code> value in the “buffGenet” column.</td>
<td>only if <code>clonal</code> <code>= TRUE</code>
</td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>species/ site/ quad/ year/ geometry</td>
<td>Five separate arguments, each a character string that indicates the
name of the column in <code>dat</code> that contains data for each of
these required data types. No value is required if the column name is
the same as the default. If only one column names is different than the
default, then you only need to supply a value for that argument.</td>
<td>No</td>
<td>“Species” /“Site” /“Quad” /“Year” /“geometry”</td>
</tr>
<tr class="even">
<td>aggByGenet</td>
<td>A logical argument (TRUE or FALSE) that determines whether the
output will be aggregated by genet.</td>
<td>No</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>printMessages</td>
<td>A logical argument (TRUE or FALSE) that determines if the function
returns informative messages.</td>
<td>No</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>flagSuspects</td>
<td>A logical argument (TRUE or FALSE) that indicates whether “suspect”
individuals will be flagged.</td>
<td>No</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>shrink</td>
<td>A numeric value. When two consecutive observations have the same
trackID, and the ratio of size_t+1 to size_t is smaller than the value
of <code>shrink</code>, the observation in year_t gets a
<code>TRUE</code> in the “Suspect” column.</td>
<td>No</td>
<td>0.10</td>
</tr>
<tr class="even">
<td>dormSize</td>
<td>A numeric value. An individual is flagged as “suspect” if it “goes
dormant” and has a size that is less than or equal to the percentile of
the size distribution for this species that is designated by
<code>dormSize</code>
</td>
<td>No</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p>Throughout this vignette, we’ll use a smaller subset of the
<code>grasslandData</code> and <code>grasslandInventory</code> data sets
that are included in <code>plantTracker</code> for examples. The subset
of <code>grasslandData</code> will be referred to as <code>dat</code>,
because it is the <code>dat</code> argument in <code><a href="../reference/trackSpp.html">trackSpp()</a></code>.
The subset of <code>grasslandInventory</code> will be referred to as
<code>inv</code>, since it is used for the <code>inv</code>
argument.</p>
<p>Here are the first few rows of the <code>dat</code> data set we’ll be
using:</p>
<pre><code><span><span class="co">#&gt; Simple feature collection with 6 features and 6 fields</span></span>
<span><span class="co">#&gt; Geometry type: POLYGON</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: -0.000160084 ymin: 0.4334812 xmax: 0.286985 ymax: 0.9419673</span></span>
<span><span class="co">#&gt; CRS:           NA</span></span>
<span><span class="co">#&gt;                 Species Type Site Quad Year sp_code_6</span></span>
<span><span class="co">#&gt; 1 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt; 2 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt; 3 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt; 4 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt; 5 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt; 6 Heteropogon contortus poly   AZ  SG2 1922    HETCON</span></span>
<span><span class="co">#&gt;                         geometry</span></span>
<span><span class="co">#&gt; 1 POLYGON ((0.237747 0.908835...</span></span>
<span><span class="co">#&gt; 2 POLYGON ((0.2833037 0.85959...</span></span>
<span><span class="co">#&gt; 3 POLYGON ((0.008583123 0.449...</span></span>
<span><span class="co">#&gt; 4 POLYGON ((0.1480142 0.46983...</span></span>
<span><span class="co">#&gt; 5 POLYGON ((0.03573306 0.5259...</span></span>
<span><span class="co">#&gt; 6 POLYGON ((0.2441894 0.52689...</span></span></code></pre>
<p>Here are the maps for one quadrat in <code>dat</code> over the first
several years of sampling:</p>
<pre><code><span><span class="co">#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Please use `linewidth` instead.</span></span>
<span><span class="co">#&gt; <span style="color: #555555;">This warning is displayed once every 8 hours.</span></span></span>
<span><span class="co">#&gt; <span style="color: #555555;">Call `lifecycle::last_lifecycle_warnings()` to see where this warning was</span></span></span>
<span><span class="co">#&gt; <span style="color: #555555;">generated.</span></span></span></code></pre>
<div class="figure" style="text-align: center">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-3-1.png" alt="**Figure 1.1**: *Spatial map of a subset of example `dat` data set*" width="720"><p class="caption">
<strong>Figure 1.1</strong>: <em>Spatial map of a subset of example
<code>dat</code> data set</em>
</p>
</div>
</div>
<div class="section level2">
<h2 id="iterate-through-sites-quadrats-and-species">
<em>2</em> Iterate through sites, quadrats, and species<a class="anchor" aria-label="anchor" href="#iterate-through-sites-quadrats-and-species"></a>
</h2>
<p>The first step of <code><a href="../reference/trackSpp.html">trackSpp()</a></code> is iterating through
<code>dat</code> first by site, then by quadrat, then by species.
<code>inv</code> is also filtered down to a single vector of sequential
sampling years for the quadrat in question. Then <code><a href="../reference/trackSpp.html">trackSpp()</a></code>
gets the appropriate <code>dorm</code>, <code>clonal</code>,
<code>buff</code>, and <code>buffGenet</code> arguments for that given
species, either by using the globally-specified value in the trackSpp()
function call, or by extracting the species-level value if the argument
was given as a data frame of unique values for each species. Then, the
data and arguments are passed to the <code><a href="../reference/assign.html">assign()</a></code> function.
This function is not exported in <code>plantTracker</code>, but the code
can be accessed by typing <code>plantTracker:::assign()</code> in the
console. The remainder of this vignette describes the process of the
<code><a href="../reference/assign.html">assign()</a></code> function.</p>
</div>
<div class="section level2">
<h2 id="track-individuals-over-time-using-the-assign-function">
<em>3</em> Track individuals over time using the
<code>assign()</code> function<a class="anchor" aria-label="anchor" href="#track-individuals-over-time-using-the-assign-function"></a>
</h2>
<p>Once the input data has been filtered down to one site, one quadrat,
and one species, then the <code><a href="../reference/assign.html">assign()</a></code> function is used to
track individuals through time. In this vignette, we will use data from
a site “AZs”, quadrat “SG2”, and the species <strong>“Heteropogon
contortus”</strong>. The <code>inv</code> vector for this quadrat is
<code>c(1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934)</code></p>
<div class="section level3">
<h3 id="get-data-for-the-first-year-of-sampling">
<em>3.1</em> Get data for the first year of sampling<a class="anchor" aria-label="anchor" href="#get-data-for-the-first-year-of-sampling"></a>
</h3>
<p>The data is subset yet again, this time for only the first year of
observations for this species in this quadrat, and stored in a data
frame called <code>tempPreviousYear</code>. In our example, data from
1922 will be stored in this data.frame.</p>
</div>
<div class="section level3">
<h3 id="group-genets-together-using-groupbygenet-and-assign-trackids-to-each-individual-in-the-first-year-of-sampling">
<em>3.2</em> Group genets together using <code>groupByGenet</code>,
and assign “trackIDs” to each individual in the first year of
sampling<a class="anchor" aria-label="anchor" href="#group-genets-together-using-groupbygenet-and-assign-trackids-to-each-individual-in-the-first-year-of-sampling"></a>
</h3>
<p>Because this is the first year of sampling, no polygons have been
grouped into genets (if <code>clonal = TRUE</code>), and none have been
assigned trackIDs. Both of these tasks are accomplished by a function
called <code>ifClonal()</code>, which is internal to
<code><a href="../reference/assign.html">assign()</a></code>. If <code>clonal = FALSE</code>, then clonality is
not allowed, and each polygon is assumed to represent a unique genet. In
this case, each polygon/row in <code>tempPreviousYear</code> is assigned
a unique “genetID” that acts as a temporary identifier that will be used
later in the function.</p>
<p>If <code>clonal = TRUE</code>, then clonality is allowed, and it is
possible for multiple polygons/rows in the raw data to represent one
genetic individual. In this case, we use a function called
<code><a href="../reference/groupByGenet.html">groupByGenet()</a></code> to group polygons together into one genet.
This function uses the <code>buffGenet</code> argument that is supplied
to <code><a href="../reference/trackSpp.html">trackSpp()</a></code>. The distance (<code>buffGenet</code> x 2) is
the maximum distance that two polygon edges can be from one another and
still be considered ramets from the same genet. In other words, Any two
polygons with edges that are less than (<code>buffGenet</code> x 2) from
one another will get the same “genetID.” <code><a href="../reference/groupByGenet.html">groupByGenet()</a></code>
creates a matrix of distances between every single polygon present in
the input data.frame, and clusters them together based on proximities
that are below the threshold indicated by <code>buffGenet.</code> Then,
basal area is summed for all ramets and stored in the “basalArea_genet”
column of <code>tempPreviousYear</code>. Also, once temporary genetIDs
have been assigned, a permanent “trackID” is given to each genet. This
is a combination of the six letter species code, year of first
observation, and an arbitrary index differentiating individuals of the
the same species and year of recruitment (e.g. HETCON_1922_3).</p>
<p>The following figure shows data for one year (1922) and one species
(<em>Heteropogon contortus</em>).</p>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-4-1.png" alt="**Figure 3.1**: *The value of 'buffGenet' used in the `trackSpp()` function can make a big difference in genetID assignments. These examples move from no genet grouping on the left, where every polygon has its own genetID, to grouping any ramets together that are less than 10 cm apart on the right. Colors and numbers indicate different genetIDs. Buffers are drawn around ramets that belong to the same genet.*" width="672"><p class="caption">
<strong>Figure 3.1</strong>: <em>The value of ‘buffGenet’ used in the
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> function can make a big difference in genetID
assignments. These examples move from no genet grouping on the left,
where every polygon has its own genetID, to grouping any ramets together
that are less than 10 cm apart on the right. Colors and numbers indicate
different genetIDs. Buffers are drawn around ramets that belong to the
same genet.</em>
</p>
</div>
</div>
<div class="section level3">
<h3 id="assign-age-and-recruitment-data-to-first-year">
<em>3.3</em> Assign age and recruitment data to first year<a class="anchor" aria-label="anchor" href="#assign-age-and-recruitment-data-to-first-year"></a>
</h3>
<p>We can also give all individuals in the first year data in the “age”
and “recruit” columns. If the first year for which there is data in
<code>dat</code> is actually the very first year the quadrat was sampled
(e.g. there are <em>Heteropogon contortus</em> observations in 1922, and
the quadrat SG2 was first sampled in 1922), then we put an “NA” in both
the “age” and “recruitment” columns. Because there was no data collected
in the previous year, we don’t know if any of these plants are new
recruits, and don’t know their age.</p>
<p>If the first year of data in <code>dat</code> – now in
<code>tempPreviousYear</code>– is <em>after</em> the first year the
quadrat was sampled (e.g. the first <em>Heteropogon contortus</em>
observations are in 1924, but the quadrat SG2 was first sampled in
1922), then we know that these individuals in
<code>tempPreviousYear</code> really are new recruits and are in their
first year, because they were not present in the previous year. They get
a “1” in both the “recruit” and “age” columns.</p>
<p>If the first year of data in <code>dat</code> is also the
<em>last</em> year that the quadrat is sampled (e.g. the first
<em>Heteropogon contortus</em> observations are in 1934, which is the
last year of sampling), then the observations in
<code>tempPreviousYear</code> get a “1” in both the “recruit” and “age”
columns, but also get an “NA” in the “size_tplus1” and “survives_tplus1”
columns. If this is the case, the <code><a href="../reference/assign.html">assign()</a></code> function still
uses <code>ifClonal()</code> to assign genetIDs to these observations
and then assigns trackIDs. But there are no further steps needed to
generate demographic data, so the function returns
<code>tempPreviousYear</code> as the result after this point.</p>
</div>
<div class="section level3">
<h3 id="compare-sequential-years-of-data-to-track-individuals-through-time">
<em>3.4</em> Compare sequential years of data to track individuals
through time<a class="anchor" aria-label="anchor" href="#compare-sequential-years-of-data-to-track-individuals-through-time"></a>
</h3>
<p>Now comes the main work of the function, which compares quadrat maps
for a species over time, and assigns the same trackID to polygons that
overlap from year to year. This is accomplished using a for loop that
compares the previous year of data to the current year of data. The loop
iterates through year by the index <em>i</em>. The “previous” year is
the year with the index <code>i-1</code> in the <code>inv</code> vector,
and the associated data is stored in the <code>tempPreviousYear</code>
data.frame. The “current” year is the year with the index <em>i</em> in
the <code>inv</code> vector, and the associated data is stored in
<code>tempCurrentYear</code> data.frame. There are multiple if-else
statements nested within this larger for loop, which I’ll explain using
a dichotomous key below.</p>
<p><a id="3_4_1"></a></p>
<div class="section level5">
<h5 id="is-there-a-gap-between-year-i-1-and-year-i">
<em>3.4.1</em> Is there a gap between year <code>i-1</code> and year
<em>i</em>?<a class="anchor" aria-label="anchor" href="#is-there-a-gap-between-year-i-1-and-year-i"></a>
</h5>
<p>Not every quadrat was sampled every year, and this is indicated in
the <code>inv</code> vector. This is one case where the
<code>dorm</code> argument input into <code><a href="../reference/trackSpp.html">trackSpp()</a></code> and then
passed to <code><a href="../reference/assign.html">assign()</a></code> comes in. The value of <code>dorm</code>
indicates how many years it is “acceptable” for a plant to disappear
from the quadrat maps and still be considered the same individual with
the same trackID. The value of <code>dorm</code> must be determined by
the user, and represents a point where it’s necessary to have some
biological knowledge about the species present in the data set. For
example, allowing dormancy makes sense for some species such as
perennial forbs, but doesn’t for large organisms such as trees.
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> allows you to specify the <code>dorm</code>
argument globally with one value, or individually for each species. The
<code>dorm</code> argument can also be a way to control how “forgiving”
you want to be with the data set. For example, if you expect that plants
were sometimes missed during the mapping or digitization process, then
allowing a dormancy value of “1” will help account for this. It’s
important to realize that using a <code>dorm</code> value of “1” or
higher will likely <em>slightly</em> overestimate growth and survival,
while using a value of “0” will likely slightly underestimate growth and
survival.</p>
<table class="table">
<colgroup>
<col width="77%">
<col width="22%">
</colgroup>
<thead><tr class="header">
<th>If a gap between <code>inv[i]</code> and <code>inv[i-1]</code>
is…</th>
<th></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>… greater than the <code>dorm</code> value + 1 (e.g. if
<code>dorm = 1</code>, inv[i] = 1923, and inv[i-1] = 1920; 1923 - 1920
&gt; (1+1)), then we don’t know if the observations in
<code>tempPreviousYear</code> survived or grew. They get an “NA” in the
“size_tplus1” and “survives_tplus1” columns ……….</td>
<td>Go to step <a href="#id_3_4_11">3.4.11</a>
</td>
</tr>
<tr class="even">
<td>… less than or equal to the <code>dorm</code> value + 1 (e.g. if
<code>dorm = 1</code>, inv[i] = 1923, and inv[i-1] = 1921; 1923 - 1921 =
(1+1)), then we can compare the data from year inv[i-1]
(<code>tempPreviousYear</code>) to data from year inv[i]
(<code>tempCurrentYear</code>) ……………………………….</td>
<td>Proceed to step <a href="#id_3_4_2">3.4.2</a>
</td>
</tr>
</tbody>
</table>
<p><a id="3_4_2"></a></p>
</div>
<div class="section level5">
<h5 id="get-data-for-year-i">
<em>3.4.2</em> Get data for year <em>i</em><a class="anchor" aria-label="anchor" href="#get-data-for-year-i"></a>
</h5>
<p>We already have data for the “previous” year (<code>inv[i-1]</code>)
stored in <code>tempPreviousYear</code>. Now that we know that the gap
between years doesn’t exceed <code>dorm</code>, we can get data from the
“current” year (<code>inv[i]</code>). We do this by subsetting
<code>dat</code> for all observations in year <code>inv[i]</code>. Then,
we use <code>ifClonal()</code> to group closely-grouped polygons into
genets if applicable, and assign genetIDs. This data set is stored in
the <code>tempCurrentYear</code> data.frame. <strong>Proceed to step <a href="#id_3_4_3">3.4.3</a>.</strong></p>
<p><a id="3_4_3"></a></p>
</div>
<div class="section level5">
<h5 id="are-there-any-observations-in-the-previous-year-invi-1">
<em>3.4.3</em> Are there any observations in the “previous” year
(<code>inv[i-1]</code>)?<a class="anchor" aria-label="anchor" href="#are-there-any-observations-in-the-previous-year-invi-1"></a>
</h5>
<p>Even if a quadrat was sampled in <code>inv[i-1]</code>, it is
possible that there weren’t actually any plants there that year.</p>
<table class="table">
<colgroup>
<col width="76%">
<col width="23%">
</colgroup>
<thead><tr class="header">
<th>If there …</th>
<th></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>… is data in <code>tempPreviousYear</code>………….</td>
<td>Proceed to step <a href="#id_3_4_4">3.4.4</a>
</td>
</tr>
<tr class="even">
<td>… is <em>not</em> data in <code>tempPreviousYear</code>……</td>
<td>Go to step <a href="#id_3_4_12">3.4.12</a>
</td>
</tr>
</tbody>
</table>
<p><a id="3_4_4"></a></p>
</div>
<div class="section level5">
<h5 id="add-a-buffer-around-the-previous-year-data">
<em>3.4.4</em> Add a buffer around the “previous” year data<a class="anchor" aria-label="anchor" href="#add-a-buffer-around-the-previous-year-data"></a>
</h5>
<p>Now a buffer is added around each polygon in
<code>tempPreviousYear</code>. This data is stored in the
<code>tempPreviousBuff</code> data.frame. This buffer is of the width
specified in the <code>buff</code> argument of <code><a href="../reference/trackSpp.html">trackSpp()</a></code>
that is passed to <code><a href="../reference/assign.html">assign()</a></code>. Adding this buffer before
comparing maps from the previous and current years allows for mapping
error and slight movement of plants between years, which is especially
likely for forbs that resprout every year. <strong>Proceed to step <a href="#id_3_4_5">3.4.5</a>.</strong></p>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-5-1.png" alt="**Figure 3.2**: *With a 10 cm buffer, these polygons in 1922 and 1923 overlap and will be identified by trackSpp() as the **same** individual and receive the same trackID*." width="576"><p class="caption">
<strong>Figure 3.2</strong>: <em>With a 10 cm buffer, these polygons in
1922 and 1923 overlap and will be identified by trackSpp() as the
<strong>same</strong> individual and receive the same trackID</em>.
</p>
</div>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-6-1.png" alt="**Figure 3.3**: *With a 5 cm buffer, these polygons in 1922 and 1923 overlap and will be identified by trackSpp() as **different** individuals and receive different trackIDs.*" width="576"><p class="caption">
<strong>Figure 3.3</strong>: <em>With a 5 cm buffer, these polygons in
1922 and 1923 overlap and will be identified by trackSpp() as
<strong>different</strong> individuals and receive different
trackIDs.</em>
</p>
</div>
<p><a id="3_4_5"></a></p>
</div>
<div class="section level5">
<h5 id="are-there-actually-any-observations-in-the-current-year-invi">
<em>3.4.5</em> Are there actually any observations in the “current”
year (<code>inv[i]</code>)?<a class="anchor" aria-label="anchor" href="#are-there-actually-any-observations-in-the-current-year-invi"></a>
</h5>
<p>Even if a quadrat was sampled in <code>inv[i]</code>, it is possible
that there weren’t actually any plants there that year.</p>
<table style="width:99%;" class="table">
<colgroup>
<col width="65%">
<col width="33%">
</colgroup>
<thead><tr class="header">
<th>If there …</th>
<th></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>… is data in <code>tempCurrentYear</code>………….</td>
<td>Proceed to step <a href="#id_3_4_7">3.4.7</a>.</td>
</tr>
<tr class="even">
<td>… is <em>not</em> data in <code>tempCurrentYear</code>…….</td>
<td>Take the entire <code>tempPreviousYear</code> data frame to step <a href="#id_3_4_6">3.4.6</a>
</td>
</tr>
</tbody>
</table>
<p><a id="3_4_6"></a></p>
</div>
<div class="section level5">
<h5 id="store-observations-as-ghosts-to-compare-to-data-from-the-next-year-invi1-during-the-next-iteration-of-the-loop-">
<em>3.4.6</em> Store observations as “ghosts” to compare to data
from the next year (<code>inv[i+1]</code>) during the next iteration of
the loop.<a class="anchor" aria-label="anchor" href="#store-observations-as-ghosts-to-compare-to-data-from-the-next-year-invi1-during-the-next-iteration-of-the-loop-"></a>
</h5>
<p>This step also involves the “dormancy” concept discussed in section
[<em>3.4.1</em>]. If dormancy is not allowed for this species
(i.e. <code>dorm = 0</code>), then the observations in question that
were “sent” to this step must be given a “0” in the “survives_tplus1”
column and an “NA” in the “size_tplus1” column. Because they are not
allowed to be dormant, if they don’t have overlapping individuals in the
current year (<code>inv[i]</code>)–which they don’t if they’re sent to
this step–then they’re dead. <strong>Take these observations to step <a href="#id_3_4_11">3.4.11</a>.</strong></p>
<p>However, if dormancy <em>is</em> allowed for this species, the
individuals that were “sent” to this step because they didn’t overlap
with anything in year <code>inv[i]</code> can be “stored” and compared
to the next set of data from year <code>i+1.</code> We call these stored
individuals “ghosts.” These ghosts will be compared to the polygons from
year <code>i+1</code>, <code>i+2</code>, etc. all the way until the
dormancy argument is exceeded. For example, if some <em>Heteropogon
contortus</em> individuals were present in 1922, but did not overlap
with any plants in 1923 and <code>dorm = 1</code>, then they are stored
as “ghosts” and their locations together with those of individuals from
1923 are compared to the mapped individuals from 1924. If these “ghosts”
have no matches in the 1924 data, then they get a “0” in the
“survives_tplus1” column since they are only allowed to be dormant for
one year. We then call these individuals “dead ghosts.” Any observations
that are sent to this step, but that were observed in a year that is
greater than 1 + <code>dorm</code> years ago, become “dead ghosts.” The
“dead ghosts” are added to the output data.frame. <strong>The “ghosts”
are saved for the next step, which is <a href="#id_3_4_12">3.4.12</a></strong></p>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-7-1.png" alt="**Figure 3.4**: *A visualization of the 'dormancy' scenario described above. The observation in 1922 has no overlap with any observation in 1923 (panels 1 and 2). However, if 'dorm' is greater than or equal to 1, we can save the 1922 observation as a 'ghost' (illustrated with a dotted border in panel 2). When compared to observations in 1924, there is an overlap! If 'dorm' = 1 (or more), then the observation in 1922 will get a '1' in the 'survives_tplus1' column. If 'dorm' = 0, then the observation in 1922 will get a '0' for survival, and the observation in 1924 will be a new recruit.*" width="672"><p class="caption">
<strong>Figure 3.4</strong>: <em>A visualization of the ‘dormancy’
scenario described above. The observation in 1922 has no overlap with
any observation in 1923 (panels 1 and 2). However, if ‘dorm’ is greater
than or equal to 1, we can save the 1922 observation as a ‘ghost’
(illustrated with a dotted border in panel 2). When compared to
observations in 1924, there is an overlap! If ‘dorm’ = 1 (or more), then
the observation in 1922 will get a ‘1’ in the ‘survives_tplus1’ column.
If ‘dorm’ = 0, then the observation in 1922 will get a ‘0’ for survival,
and the observation in 1924 will be a new recruit.</em>
</p>
</div>
<p><a id="3_4_7"></a></p>
</div>
<div class="section level5">
<h5 id="are-there-any-overlaps-between-polygons-in-temppreviousyear-and-tempcurrentyear">
<em>3.4.7</em> Are there any overlaps between polygons in
<code>tempPreviousYear</code> and <code>tempCurrentYear</code>?<a class="anchor" aria-label="anchor" href="#are-there-any-overlaps-between-polygons-in-temppreviousyear-and-tempcurrentyear"></a>
</h5>
<p>Use the <code>st_intersection</code> function from the sf package to
determine if there is any overlap between polygons in the the previous
year (<code>inv[i-1]</code>, stored in<code>tempPreviousYear</code>) and
the current year (<code>inv[i]</code>, stored in
<code>tempCurrentYear</code>).</p>
<table class="table">
<colgroup>
<col width="64%">
<col width="35%">
</colgroup>
<thead><tr class="header">
<th>If there …</th>
<th></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>… is overlap between <code>tempPreviousYear</code> and
<code>tempCurrentYear</code>………………</td>
<td>Proceed to step <a href="#id_3_4_8">3.4.8</a>
</td>
</tr>
<tr class="even">
<td>… is <em>not</em> overlap between <code>tempPreviousYear</code> and
<code>tempCurrentYear</code>…</td>
<td>Take the <code>tempPreviousYear</code> data frame to step <a href="#id_3_4_6">3.4.6</a>.Take the <code>tempCurrentYear</code> data
frame to step <a href="#id_3_4_12">3.4.12</a>, but first assign them a
“1” in the “recruit” column and a “1” in the “age” column.</td>
</tr>
</tbody>
</table>
<p><a id="3_4_8"></a></p>
</div>
<div class="section level5">
<h5 id="compare-the-overlap-between-temppreviousyear-and-tempcurrentyear-to-assign-trackids-">
<em>3.4.8</em> Compare the overlap between
<code>tempPreviousYear</code> and <code>tempCurrentYear</code> to assign
trackIDs.<a class="anchor" aria-label="anchor" href="#compare-the-overlap-between-temppreviousyear-and-tempcurrentyear-to-assign-trackids-"></a>
</h5>
<p>The <code>st_intersection</code> function used in step <strong><a href="#id_3_4_7">3.4.7</a></strong> returns a matrix that gives the
total area of overlap between each genet in
<code>tempPreviousYear</code> and each genet in
<code>tempCurrentYear</code> (the “overlap matrix”). There are two
options from here, depending if <code>clonal = TRUE</code> or
<code>FALSE</code>.</p>
<p>If <code>clonal = TRUE</code>, each “parent” (those in
<code>tempPreviousYear</code>) can be represented by more than one
polygon. However, all polygons that are part of the same genet have the
same trackID. “Child” polygons (those in <code>tempCurrentYear</code>)
have not yet been grouped by genet, and do not have trackIDs assigned.
The “overlap matrix” is aggregated by parent trackID so that each parent
trackID has only one row in the matrix. The “overlap matrix” has a
column for each potential child polygon. Each “child” polygon (those in
<code>tempCurrentYear</code>) can have only one parent trackID (but can
have multiple parent polygons). Each “parent” (those in
<code>tempPreviousYear</code>) can have multiple child polygons. In
other words, each row (parent) of the “overlap matrix” is allowed to
have overlap values in more than one column, but each column (child) of
the matrix can only have one overlap value.</p>
<p>If each column of the overlap matrix has only one overlap value, then
the next step is straightforward. Each overlapping “child” polygon is
given the trackID of it’s “parent” in the <code>tempCurrentYear</code>
data frame. If there are multiple “children” that overlap with the same
parent, those children are considered to be ramets of the same genet.
If, however, a “child” overlaps with multiple parents (i.e. a column has
values in more than one row), then we need to determine which potential
“parent” is more likely the true parent. This “tie” is first broken by
comparing the overlap area. The true “parent” is the parent with the
highest degree of overlap with the “child”. In the rare case of a tie
in<br>
overlap area, the parent polygon with a centroid closest to the centroid
of the child polygon is identified as the true “parent”. All other
values in that child column are turned to “NA”s.</p>
<p>If <code>clonal = FALSE</code>, then each “child” can have only one
“parent”, and each “parent” only one “child”. In this case, the
<code><a href="../reference/assign.html">assign()</a></code> function uses a while loop to look through the
matrix generated by step 3.4.7. The highest value in the matrix
indicates the greatest degree of overlap between a given “parent” and
“child.” The trackID from that parent is given to that child. Then, the
overlap values in the entire “parent” row and “child” columns in the
overlap matrix are changed to zero, since each parent can have only one
child and each child can have only one parent. The while loop repeats
this process of finding the highest value in the matrix to assign
trackIDs until the entire matrix has no non-zero values left.</p>
<p>Take both the <code>tempCurrentYear</code> (child) and
<code>tempPreviousYear</code> (parent) data frames to step <strong><a href="#id_3_4_9">3.4.9</a></strong>.</p>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-8-1.png" alt="**Figure 3.5**: *Here are the data for *Heteropogon contortus* in 1922 and 1923. A 5 cm buffer is shown around each genet in 1922. Data from both years have been grouped by genet using 'buffGenet' = .01*" width="672"><p class="caption">
<strong>Figure 3.5</strong>: <em>Here are the data for </em>Heteropogon
contortus* in 1922 and 1923. A 5 cm buffer is shown around each genet in
1922. Data from both years have been grouped by genet using ‘buffGenet’
= .01*
</p>
</div>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-9-1.png" alt="**Figure 3.6**: *Here are the buffered data for Heteropogon contortus from 1922, overlapped with the data from 1923.*" width="432"><p class="caption">
<strong>Figure 3.6</strong>: <em>Here are the buffered data for
Heteropogon contortus from 1922, overlapped with the data from
1923.</em>
</p>
</div>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-10-1.png" alt="**Figure 3.7**: *Here are the trackID assignments for these two years of data. Each trackID has a different color and a different number.*" width="672"><p class="caption">
<strong>Figure 3.7</strong>: <em>Here are the trackID assignments for
these two years of data. Each trackID has a different color and a
different number.</em>
</p>
</div>
<p><a id="3_4_9"></a></p>
</div>
<div class="section level5">
<h5 id="flag-any-suspect-observations">
<em>3.4.9</em> Flag any suspect observations<a class="anchor" aria-label="anchor" href="#flag-any-suspect-observations"></a>
</h5>
<p>If <code>flagSuspects = FALSE</code>, proceed directly to step
<strong><a href="#id_3_4_10">3.4.10</a></strong>. If
<code>flagSuspects = TRUE</code>, the following checks take place. The
first check identifies and flags any individuals in the previous year
that became substantially smaller in the current year. For example,
there are two overlapping observations in consecutive years that the
function has given the same trackID. The observation in the previous
year has a basal area of 20 cm<span class="math inline">\(^2\)</span>,
and the observation in the current year has a basal area of 1.5 cm<span class="math inline">\(^2\)</span>. It is possible that these two are in
fact the same individual, but it is also possible that the observation
in the current year is a new recruit that happens to be in a similar
location to the larger plant in the previous year. If
<code>flagSuspects = TRUE</code>, any individual from the previous year
(any “parent”) that has a basal area in the current year below a certain
percentage of its size will be get a “TRUE” in the “Suspect” column.
This threshold is defined by the <code>shrink</code> argument, which has
a default value of 0.10 (10%). To use our previous example, if
<code>shrink = .10</code>, the individual with a basal area of 20
cm<span class="math inline">\(^2\)</span> in the previous year will be
flagged as “suspect” because it has shrunk to below 10% of its size.</p>
<p>The second check flags very small individuals that go dormant. This
check is only used if the <code>dorm</code> argument is set to “1” or
higher, and if the observations were measured as polygons. This check
can’t be used for observations that were measured as points and
converted to small polygons of a fixed size, since we don’t know the
plant’s true size. A plant with a very small basal area is unlikely to
actually survive dormancy. It is possible that the tracking function has
correctly given the same trackID to a very small individual that is
present in year 1, absent in year 2, and present again in year 3.
However, it is also very possible that this very small individual died,
and the observation in year 3 is a new recruit. This check puts a
<code>TRUE</code> in the “suspect” column of any “parent” individual
that “survives” dormancy if it is below a certain percentile of the size
distribution for that species (which is created using the size data for
that species provided in <code>dat</code>). The percentile threshold is
defined by the <code>dormSize</code> argument, which has a default value
of 0.05 (5%).</p>
<p>Once these checks are complete, the <code>tempCurrentYear</code>
(child) and <code>tempPreviousYear</code> (parent) data frames go to
step <strong><a href="#id_3_4_10">3.4.10</a></strong>.</p>
<p>It is important to note that, even though these checks flag
individuals whose trackID assignment might be “suspect”, the
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> function still proceeds as it would if
<code>flagSuspects</code> was set to <code>FALSE</code>. It is up to the
user whether they want to exclude “suspect” observations from subsequent
analyses. If you do not exclude these observations, it is possible that
you would slightly overestimate survival, and underestimate recruitment
and growth.</p>
<p><a id="3_4_10"></a></p>
</div>
<div class="section level5">
<h5 id="separate-the-ghosts-and-the-new-recruits-from-the-parent-and-child-data-frames">
<em>3.4.10</em> Separate the “ghosts” and the new recruits from the
“parent” and “child” data frames<a class="anchor" aria-label="anchor" href="#separate-the-ghosts-and-the-new-recruits-from-the-parent-and-child-data-frames"></a>
</h5>
At this point, the <code>tempPreviousYear</code> data frame gets broken
into a <code>parents</code> data.frame, which contains data for all
those genets that have a “child” in the current year, and a
<code>ghosts</code> data.frame, which contains data for those genets
that do not have a “child.” The <code>tempCurrentYear</code> data frame
is broken into a <code>children</code> data.frame, containing the data
for all those genets that have a “parent” in the previous year, and an
<code>orphans</code> data.frame, which contains the data for genets that
do not have a parent.
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-11-1.png" alt="**Figure 3.8**: *Here is a visualization of how the observations are broken into 'parents', 'ghosts', 'children', and 'orphans'.*" width="672"><p class="caption">
<strong>Figure 3.8</strong>: <em>Here is a visualization of how the
observations are broken into ‘parents’, ‘ghosts’, ‘children’, and
‘orphans’.</em>
</p>
</div>
<p><strong>The <code>ghosts</code> data frame is sent to step <a href="#id_3_4_6">3.4.6.</a></strong> All of the observations in the
<code>parents</code> data frame get a “1” in the “survives_tplus1”
column, and the total genet area of their “child” is put into the
“size_tplus1” column. Then, <strong>the <code>parents</code> data frame
is sent to step <a href="#id_3_4_11">3.4.11</a></strong> All of the
observations in the <code>children</code> data frame get a “0” in the
“recruit” column, the age column is populated with 1 + the age of their
parent. The observations in the <code>orphans</code> data frame get a
“1” in the “recruit” column and a “1” in the “age” column. However if
the <code>orphans</code> occur after a gap in sampling, they instead get
an “NA” in the “recruit” and “age” columns, since we don’t know whether
they were recruited in year <em>i</em> or during the gap. Then,
<strong>both the</strong> <strong><code>children</code> and
<code>orphans</code> data.frames are sent to step <a href="#id_3_4_12">3.4.12</a>.</strong></p>
<p><a id="3_4_11"></a></p>
</div>
<div class="section level5">
<h5 id="store-the-resulting-demographic-data">
<em>3.4.11</em> Store the resulting demographic data<a class="anchor" aria-label="anchor" href="#store-the-resulting-demographic-data"></a>
</h5>
<p>Now demographic data (or NAs, if appropriate) and trackIDs have been
assigned to every individual in <code>tempPreviousYear</code> (if there
are actually observations in <code>inv[i-1]</code>), we can save these
results. They are added to a data frame that, when the for loop
finishes, will be returned by the <code><a href="../reference/assign.html">assign()</a></code> function. If
there are any “dead ghosts”, they are also added to the output
data.frame. If <code>inv[i]</code> is <em>not</em> the last year of
sampling, then proceed to step <strong><a href="#id_3_4_12">3.4.12</a></strong>. If <code>inv[i]</code>
<em>is</em> the last year of sampling, then the for loop is over!</p>
<p><a id="3_4_12"></a></p>
</div>
<div class="section level5">
<h5 id="get-ready-for-the-next-iteration-of-the-loop">
<em>3.4.12</em> Get ready for the next iteration of the loop<a class="anchor" aria-label="anchor" href="#get-ready-for-the-next-iteration-of-the-loop"></a>
</h5>
<p>If there are still iterations of the loop left, that is if
<code>inv[i]</code> is not the last year of <code>inv</code>, then the
data from year[i] (stored either in <code>tempCurrentYear</code> or
<code>children</code> and <code>orphans</code>) and any ‘ghosts’ from
previous years are put into the <code>tempPreviousYear</code>
data.frame. This happens even if <code>tempCurrentYear</code> is empty.
If there are not already genetIDs assigned to the data from
<code>inv[i]</code> in <code>tempCurrentYear</code> (which happens if
this is the first year after a gap in sampling), then it is passed
through <code>ifClonal()</code>. The loop proceeds to the next value of
<em>i</em> (start again at section <strong><a href="#id_3_4_1">3.4.1</a></strong>).</p>
<p>Once the loop has progressed through the ‘last’ year, then the output
data set will be saved, and the next species in the data set will be
sent to <code><a href="../reference/assign.html">assign()</a></code>!</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="prepare-the-trackspp-results-to-be-returned">
<em>4</em> Prepare the <code>trackSpp()</code> results to be
returned!<a class="anchor" aria-label="anchor" href="#prepare-the-trackspp-results-to-be-returned"></a>
</h2>
<p>There are just a few more steps in <code><a href="../reference/trackSpp.html">trackSpp()</a></code> after the
<code><a href="../reference/assign.html">assign()</a></code> function has been applied to every species present
in the data set.</p>
<div class="section level3">
<h3 id="aggregate-the-results-by-genet">
<em>4.1</em> Aggregate the results by genet<a class="anchor" aria-label="anchor" href="#aggregate-the-results-by-genet"></a>
</h3>
<p>The data.frames returned by the <code><a href="../reference/assign.html">assign()</a></code> function are
the exact same length as the input data frames. This means that, even
though trackIDs and demographic data are assigned on the genet level,
each ‘observation’, or ramet, has its own row of data. If the
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> argument <code>aggByGenet = TRUE</code>, the
output data set is passed through the <code><a href="../reference/aggregateByGenet.html">aggregateByGenet()</a></code>
function from <code>plantTracker</code>. This aggregates the data set so
that each genet in each year is represented by only one row of data. The
polygons for each ramet are combined into one spatial object using the
<code>st_union</code> function from the <code>sf</code> package. The
resulting data frame will be shorter and narrower than the input
data.frame, since rows are combined. While the output of the
<code><a href="../reference/assign.html">assign()</a></code> function contains a column for “basalArea_ramet”,
this column is no longer present once the results are aggregated.</p>
<p>If there were any columns in the input data frame beyond those
required (Species, Site, Quad, Year, geometry), these will be dropped
also, since the function can’t predict whether it will be possible to
aggregate those on the genet level. If your input data frame has data in
additional columns that can be aggregated and that you want to keep with
the demographic data, I recommend using <code>aggByGenet = FALSE</code>.
If you want to ultimately aggregate the demographic data by genet, you
can use the <code><a href="https://r-spatial.github.io/sf/reference/aggregate.sf.html" class="external-link">sf::aggregate</a></code> function on your own, or modify
the code for the <code><a href="../reference/aggregateByGenet.html">aggregateByGenet()</a></code> function to include
your additional columns. If you have set <code>clonal = FALSE</code> for
all species in your input data.frame, I also recommend using
<code>aggByGenet = FALSE</code>, since your results will already be on
the genet scale!</p>
</div>
<div class="section level3">
<h3 id="informative-messages">
<em>4.2</em> Informative messages<a class="anchor" aria-label="anchor" href="#informative-messages"></a>
</h3>
<p>If the argument <code>printMessages = TRUE</code>, one or two
messages will be printed as each species goes through the
<code><a href="../reference/assign.html">assign()</a></code> function. These messages are not warnings or
errors! Unless the function returns a message preceded by the word
“warning” or “error”, the function is working! The messages I’m talking
about here provide information about why there are “NA”s present in the
demographic results, which may be concerning if you aren’t expecting
them. The first message tells you which year is the last year of
sampling for this quadrat. Observations in the last year of sampling
will have an “NA” in both the “survives_tplus1” and “size_tplus” columns
because we have no data to determine whether they survived. The second
message only appears if there is a gap in sampling for that quadrat that
exceeds the <code>dorm</code> argument. The message indicates that
observations in the year(s) preceding that gap will have “NA”s in the
“survives_tplus1” “size_tplus1” columns, since we don’t know when they
died. If both <code>printMessages = TRUE</code> and
<code>aggByGenet = TRUE</code>, an additional message will be printed.
This message will warn that the output data frame is shorter and
narrower than the input data.frame, and will explain why that is.</p>
<p>Lastly, if <code>printMessages = TRUE</code>, the
<code><a href="../reference/trackSpp.html">trackSpp()</a></code> function will print progress messages that
indicate which site is being run the function, then which species, then
which quadrat. This is helpful both to know how far the function has
gotten in your data, and also is helpful if the function errors out. You
can find roughly where the problem in the data is, since you know the
species, quadrat, and site where the function crashed.</p>
<p>If <code>printMessages = FALSE</code>, then no messages will be
returned.</p>
</div>
</div>
<div class="section level2">
<h2 id="examples">
<em>5</em> Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h2>
Here are the trackID assignments for 4 years of observations of
<em>Heteropogon contortus</em> from a subset of the SG2 quadrat near
Tucson, Arizona. The <code>trackSpp</code> function here uses
<code>dorm = 1</code>, <code>clonal = TRUE</code>,
<code>buff = 0.05</code> and <code>buffGenet = 0.01</code>.<br><div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-12-1.png" alt="**Figure 5.1**: *Here are the trackID assignments over 4 years of data. Each trackID is shown as a different color and has a different number.*" width="672"><p class="caption">
<strong>Figure 5.1</strong>: <em>Here are the trackID assignments over 4
years of data. Each trackID is shown as a different color and has a
different number.</em>
</p>
</div>
Here is that same data subset, but run through <code><a href="../reference/trackSpp.html">trackSpp()</a></code>
using a buffGenet value of .05
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-13-1.png" alt="**Figure 5.2**: *Here are the trackID assignments over 4 years of data. Each trackID is shown as a different color and has a different number.*" width="672"><p class="caption">
<strong>Figure 5.2</strong>: <em>Here are the trackID assignments over 4
years of data. Each trackID is shown as a different color and has a
different number.</em>
</p>
</div>
Here it is again, but run through <code><a href="../reference/trackSpp.html">trackSpp()</a></code> using
<code>clonal = FALSE</code>
<div class="figure" style="text-align: left">
<img src="Using_the_plantTracker_trackSpp_function_files/figure-html/unnamed-chunk-14-1.png" alt="**Figure 5.3**: *Here are the trackID assignments over 4 years of data. Each trackID is shown as a different color and has a different number.*" width="672"><p class="caption">
<strong>Figure 5.3</strong>: <em>Here are the trackID assignments over 4
years of data. Each trackID is shown as a different color and has a
different number.</em>
</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Alice Stears, Jared Studyvin, David Atkins.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
