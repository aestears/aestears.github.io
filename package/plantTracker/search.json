[{"path":"http://www.astearsresearch.com/package/plantTracker/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Alice Stears Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Suggested `plantTracker` Workflow","text":"Welcome plantTracker! package designed transform long-term quadrat maps show plant occurrence size demographic data can used answer questions population community ecology. vignette designed help use plantTracker functions move spatially referenced dataset containing plant cover data, output dataset contains growth survival data observed individual. vignette walk steps get maps plant cover demographic dataset can use analysis!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"prepare-data","dir":"Articles","previous_headings":"","what":"1. Prepare data","title":"Suggested `plantTracker` Workflow","text":"functions plantTracker require data specific format. plantTracker includes example dataset consists two pieces: grasslandData grasslandInventory. can load example datasets global environment calling data(grasslandData) data(grasslandInventory). can view documentation datasets calling ?grasslandData ?grasslandInventory. plantTracker functions require two data objects. first data frame contains location metadata mapped individual, now call dat. second list contains vector years quadrat sampled, now cal inv. basic requirements data objects.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"the-dat-data-frame-must------","dir":"Articles","previous_headings":"1. Prepare data","what":"1.1 The dat data frame must . . .","title":"Suggested `plantTracker` Workflow","text":"… sf data.frame. section 1.1.1… … contain row individual observation year. … column contains character strings indicating specific epithet observation. column must character data type. function expects column called “Species”, different name can specified function calls. … column contains character strings indicating site observation collected. level classification “” quadrat (.e. quadrats measured Central Plains Experimental Range Nunn, CO might value “CO” column). column must character data type. function expects column called “Site”, different name can specified function calls. … column contains character strings indicating quadrat observation collected. column must character data type. function expects column called “Quad”, different name can specified function calls. … column contains value indicating year individual observation collected. must numeric data type, must either four two digit year number. function expects column called “Year”, different name can specified function calls. data collected forbs small grasses mapped points digitized , observations must converted polygons. recommend convert small circular polygons identical radius. transformation, also recommend include column indicates whether row originally mapped polygon point, since demographic data deals size relatively meaningless observations originally mapped points. dat need coordinate reference system (.e. CRS can “NA”), can one ’d like. … columns called “neighbors”, “nearEdge”, “trackID”, “age”, “size_tplus1”, “recruit”, “survives_tplus1”, “basalArea_ramet”, “basalArea_genet”, since columns added plantTracker functions. Note: Additional columns can included input data.frame, although might included output plantTracker functions. first rows possible dat input data.frame: Note: required columns “Species”, “Site”, “Quad”, “Year”, “geometry”. additional columns “Type” “sp_code_6” just “along ride” analysis using plantTracker functions. Figure 1.1 : Spatial map subset example ‘dat’ dataset ’s important note , plantTracker designed used small-scale maps plant occurrence quadrats, conceivably possible use styles map data plantTracker functions. required single mapped basal area (point location converted small polygon) time point organism (ramet), accompanied required metadata detailed . example, plantTracker functions used estimate tree demographic rates scale 100 m x 50 m plots.","code":"#> Simple feature collection with 6 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -0.000160084 ymin: 0.4334812 xmax: 0.286985 ymax: 0.9419673 #> CRS:           NA #>                 Species Type Site Quad Year sp_code_6 #> 1 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 2 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 3 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 4 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 5 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 6 Heteropogon contortus poly   AZ  SG2 1922    HETCON #>                         geometry #> 1 POLYGON ((0.237747 0.908835... #> 2 POLYGON ((0.2833037 0.85959... #> 3 POLYGON ((0.008583123 0.449... #> 4 POLYGON ((0.1480142 0.46983... #> 5 POLYGON ((0.03573306 0.5259... #> 6 POLYGON ((0.2441894 0.52689..."},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"get-your-data-into-the-sf-data-format","dir":"Articles","previous_headings":"1. Prepare data > 1.1 The dat data frame must . . .","what":"1.1.1 Get your data into the sf data format","title":"Suggested `plantTracker` Workflow","text":"mentioned , plantTracker uses sf R package deal spatial data. map data plantTracker built analyze inherently spatial, need know basics dealing spatial data R want use plantTracker! many good resources help orient working spatial data R generally: https://cengel.github.io/R-spatial/intro.html https://www.r-bloggers.com/2021/06/using-geospatial-data--r/ sf package specifically: https://cran.r-project.org/web/packages/sf/sf.pdf https://r-spatial.github.io/sf/ resources provide great orientation, recommend looking ’re new working spatial data R, ’ve included brief tutorial uploading shapefiles R sf data frames. published chart-quadrat datasets map data stored shapefiles complex file structures, can bit confusing navigate. plantTracker requires data (species, plots years) one single data frame, code shows navigate complex file structure pull shapefiles put one single sf data frame. example, ’ll use data Central Plains Experimental Research Location Colorado, published data paper. dataset, shapefiles quadrat stored folder. Within folder two shapefiles year: one contains map data polygons, one contains data points. following code reads shapefiles, transforms points polygons fixed radius, puts data one sf data frame. want follow along, download “shapefiles.zip” file data paper, un-zip , name “CO_shapefiles”.","code":"#  save a character vector of the file names in the file that contains the  # shapefiles (in this case, called \"CO_shapefiles\"), each of which is a quadrat # note: 'wdName' is a character string indicating the path of the directory  # containing the 'CO_shapefiles' folder quadNames <- list.files(paste0(wdName,\"CO_shapefiles/\"))  # now we'll loop through the quadrat folders to download the data for (i in 1:2){#length(quadNames)) {   # get the names of the quadrat for this iteration of the loop   quadNow <- quadNames[i]   #  get a character vector of the unique quad/Year combinations of data in    # this folder that contain polygon data   quadYears <- quadYears <-  unlist(strsplit(list.files(     paste0(wdName, \"CO_shapefiles/\",quadNow,\"/\"),     pattern = \".shp$\"), split = \".shp\"))   # loop through each of the years in this quadrat   for (j in 1:length(quadYears)) {     # save the name of this quadYear combo     quadYearNow <- quadYears[j]     # read in the shapefile for this quad/year combo as an sf data frame      # using the 'st_read()' function from the sf package      shapeNow <- sf::st_read(dsn = paste0(wdName,\"CO_shapefiles/\",quadNow),                              #  the 'dsn' argument is the folder that                              # contains the shapefile files--in this case,                              # the folder for this quadrat                             layer = quadYearNow) # the 'layer' argument has the      # name of the shapefile, without the filetype extension! This is because each      # shapefile consists of at least three separate files, each of which has a      # unique filetype extension.      # the shapefiles in this dataset do not have all of the metadata we      # need, and have some we don't need, so we'll remove what we don't need and      # add columns for 'site', 'quad', and 'year'     shapeNow$Site <- \"CO\"     shapeNow$Quad <- quadNow     # get the Year for the shapefile name--in this case it is the last for      # numbers of the name     shapeNow$Year <- as.numeric(strsplit(quadYearNow, split = \"_\")[[1]][4])     # determine if the 'current' quad/year contains point data or polygon data     if (grepl(quadYearNow, pattern = \"^pnt\")) { # if quadYearNow has point data       # remove the columns we don't need       shapeNow <- shapeNow[,!(names(shapeNow)                               %in% c(\"coords_x1\", \"coords_x2\", \"coords_x1_\",                                       \"coords_x2_\", \"coords_x1.1\", \"coords_x2.1\"))]       # reformat the point into a a very small polygon        # (a circle w/ a radius of .003 m)       shapeNow <- sf::st_buffer(x = shapeNow, dist = .003)       # add a column indicating that this observation was originally        # mapped as a point       shapeNow$type <- \"point\"     } else { # if quadYearNow has polygon data       # remove the columns we don't need       shapeNow <- shapeNow[,!(names(shapeNow) %in% c(\"SP_ID\", \"SP_ID_1\", \"x\", \"y\", \"area\"))]       # add a column indicating that this observation was originally        # mapped as a polygon       shapeNow$type <- \"polygon\"     }     # now we'll save this sf data frame      if (i == 1 & j == 1) { # if this is the first year in the first quadrat       outDat <- shapeNow     } else { # if this isn't the first year in the first quadrat, simply rbind        # the shapeNow sf data frame onto the previous data        outDat <- rbind(outDat, shapeNow)     }   } }  # Now, all of the spatial data are in one sf data frame, and are ready to be used in plantTracker functions!"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"the-inv-list-must------","dir":"Articles","previous_headings":"1. Prepare data","what":"1.2 The inv list must . . .","title":"Suggested `plantTracker` Workflow","text":"… named list … element names character string identical name quadrat dat. two elements name, element one quadrat name. must element quadrat data dat. … list elements numeric vector years quadrat sampled. quadrat “skipped” year, year must excluded vector. format years must format years dat (.e. year four-digit number dat, must four-digit number inv). Make sure years quadrat actually sampled, just years data dat data frame! argument allows function differentiate years quadrat wasn’t sampled years just weren’t individuals species present quadrat. quadrat wasn’t sampled given year, don’t put ‘NA’ inv year! Instead, just skip year. example inv argument corresponds example dat argument . quadrats data dat “SG2” “SG4”, elements inv correspond quadrats. already quadrat inventory data frame, isn’t complicated reformat work plantTracker functions. example, quadrat inventory data frame looks like … : … following get format ready plantTracker:","code":"#> $SG2 #> [1] 1922 1923 1924 1925 1926 1927 #>  #> $SG4 #> [1] 1922 1923 1924 1925 1926 1927 #>   quad1 quad2 quad3 #> 1  2000  2000  2000 #> 2  2001  2001    NA #> 3    NA  2002  2002 #> 4  2003  2003  2003 #> 5  2004  2004  2004 #> 6  2005  2005  2005 #> 7  2006  2006  2006 #> 8  2007  2007  2007 quadInv_DF <- data.frame(\"quad1\" = c(2000, 2001, NA, 2003, 2004, 2005, 2006, 2007),            \"quad2\" = c(2000:2007),             \"quad3\" = c(2000, NA, 2002, 2003, 2004, 2005, 2006, 2007))  # use the 'as.list()' function to transform your data frame into a named list quadInv_list <- as.list(quadInv_DF) # we still need to remove the 'NA' values, which we can do using the  # 'lapply()' function (quadInv_list <- lapply(X = quadInv_list, FUN = function(x) x[is.na(x) == FALSE])) #> $quad1 #> [1] 2000 2001 2003 2004 2005 2006 2007 #>  #> $quad2 #> [1] 2000 2001 2002 2003 2004 2005 2006 2007 #>  #> $quad3 #> [1] 2000 2002 2003 2004 2005 2006 2007"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"check-the-inv-and-dat-arguments-using-checkdat","dir":"Articles","previous_headings":"1. Prepare data","what":"1.3 Check the inv and dat arguments using checkDat()","title":"Suggested `plantTracker` Workflow","text":"generic checkDat() function: step optional, can useful ’re unsure whether dat inv arguments correct format. plantTracker function checkDat() takes dat inv arguments arguments dat inv, return informative error messages either argument correct format. Additional optional arguments checkDat() species, site, quad, year, geometry, reformatDat. species/site/quad/year/geometry arguments need included columns dat contain data species, site, quadrat, year geometry observation different names “Species”, “Site”, “Quad”, “Year, ”geometry“. example, column version dat contains species identity observation called”species_names\", argument species = \"species_names\" must included call checkDat(). reformatDat TRUE/FALSE argument determines whether want checkDat() function return version dat ready go steps workflow. reformatDat = TRUE checkDat() return list contains reformatted version dat, reformatted version inv additional element called “userColNames”, contains column names input version dat different expected column names “Species”, “Site”, “Quad”, “Year, ”geometry\" (). reformatDat = TRUE, checkDat() return message indicating data ready next step. default value FALSE.","code":"checkDat(dat, inv = NULL, species = \"Species\", site = \"Site\", quad = \"Quad\",   year = \"Year\", geometry = \"geometry\", reformatDat = FALSE, ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"track-individuals-through-time-using-trackspp","dir":"Articles","previous_headings":"","what":"2 Track individuals through time using trackSpp()","title":"Suggested `plantTracker` Workflow","text":"Now ’s time transform raw dataset demographic data! accomplished using trackSpp() function. function follows individual plants year year quadrat determine survival, size next year, age, additional potentially-useful demographic data. comparing quadrat maps sequential years. overlap individuals species consecutive years, rows dat contain data overlapping individuals given “trackID”, unique identifier. generic trackSpp() function:","code":"trackSpp(dat, inv, dorm, buff, buffGenet, clonal, species = \"Species\",   site = \"Site\", quad = \"Quad\", year = \"Year\", geometry = \"geometry\",   aggByGenet = TRUE, printMessages = TRUE, flagSuspects = FALSE,   shrink = 0.1, dormSize = 0.05, ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"function-arguments","dir":"Articles","previous_headings":"2 Track individuals through time using trackSpp()","what":"2.1 Function arguments","title":"Suggested `plantTracker` Workflow","text":"trackSpp() takes following arguments: dat sf data frame ’ve calling dat far. must correct format (can check -hand using checkDat()), informative error messages returned incorrect. must columns outlined Section 1.1, can different names long names included function call (later…). inv list quadrat sampling years ’ve calling inv. correct format contain data correct quadrats, informative error message returned. dorm positive integer value indicates long want function allow individual “dormant”. case, dormancy can interpreted biological phenomenon plant -ground tissue present year 1, alive underground -ground tissue year 2, -ground tissue subsequent year. Dormancy can also interpreted data-collection error, whereby individual accidentally mapped years recorded. Consider following example: polygon species “” year 1, “focal individual”. year 2, polygon species “” overlaps focal individual. year 3, polygon species “” location focal individual. dorm = 0, focal individual get 0 survival column, polygon species “” year 3 considered new recruit get new trackID. dorm = 1, overlap two polygons species 1-year gap occur, two polygons considered genetic individual, trackID, focal individual “1” survival column. alternative scenario, years 3 4 polygons species “” location focal individual, polygon year 4 overlaps focal individual. dorm = 1, focal individual get “0” survival, dorm = 2, get 1 survival. Figure 2.1: visualization ‘dormancy’ scenario described . ’d like specific perhaps biologically accurate, can also specify dorm argument uniquely species. example, might confident data collectors accidentally “miss” individuals, dat data frame contains observations shrubs trees, unlikely go dormant, small forbs, much likely go dormant one two years. order disallow dormancy trees shrubs, allow dormancy forbs, provide data frame dorm argument instead single positive integer value. two columns: 1) “Species” column species name species present dat, 2) column called “dorm” positive integer values indicating dormancy ’d like allow species. Make sure following data frame approach, must provide dormancy argument every species data dat. Make sure species names dorm data frame spelled exactly dat. data frame look something like : Important Note: careful define dorm argument. bigger dorm argument, likely overestimate survival. annually-sampled data, need biologically-compelling reason specify dorm argument greater 1 year. buff positive numeric value indicates much individual can move year 1 year 2 still considered individual (receive trackID). addition accounting true variation location plant’s stem year year, argument also accounts small inconsistencies mapping year year. buff argument must units spatial values dat. example, spatial data dat measured meters, want allow plant “move” 15 cm year 1 year 2, include argument buff = .15 call trackSpp(). want allow movement, use buff = 0. visualization two different buff scenarios. Figure 2.2: 10 cm buffer, polygons 1922 1923 overlap identified trackSpp() individual receive trackID. Figure 2.3: 3 cm buffer, polygons 1922 1923 don’t quite overlap, identified trackSpp() different individuals receive different trackIDs. clonal logical argument (TRUE FALSE) indicates whether want allow plants clonal . context type data, “clonal” means one genetic individual (“genet”) can recorded multiple polygons (“ramets”). clonal = TRUE, multiple polygons year can part individual trackID. clonal = FALSE, every polygon given year unique individual unique trackID. option can defined globally species present dat setting clonal equal FALSE TRUE trackSpp() function call. Alternatively, clonal can specified uniquely species creating data frame contains clonal argument species (analogous data frame dorm argument shown Table 2.1, column called “clonal”). following arguments trackSpp() required certain contexts. buffGenet argument required clonal = TRUE clonal data frame contains least single TRUE “clonal” column. buffGenet numeric value indicates close polygons species must one another first year order considered parts genetic individual (ramets genet). Similar buff, careful conservative defining argument. large value buffGenet can quickly lead entire quadrat treated genetic individual! suggest experimenting multiple values buffGenet, looking maps show trackID assignment, deciding value leads trackID assignments make biological sense . argument passed groupByGenet() function, assigns trackID individuals within buffGenet buffer . Polygons grouped genet first year data. point, grouping genet happens based data previous years. multiple polygons overlap genet previous year, given trackID considered ramets belonging genet. value buffGenet must greater equal zero, must units spatial data dat. buffGenet can single numeric value applied species present dat, can specified uniquely species creating data frame contains buffGenet argument species (analogous data frame dorm argument shown Table 2.1, column called “buffGenet”). aggByGenet logical argument required clonal = TRUE clonal data frame contains least single TRUE “clonal” column. argument determines whether output data frame trackSpp() row every single ramet, aggregated genet represented single row. aggByGenet = FALSE, output aggregated. aggByGenet = TRUE (default setting), results aggregated using plantTracker function aggregateByGenet(). function combines sf “POLYGONS” ramet one sf MULTIPOLYGON entire genet, combines associated metadata (“Species”, “Site”, “Quad”, “Year”, “trackID”, “basalArea_genet”, “age”, “recruit”, “survives_tplus1”, “size_tplus1”, “nearEdge”) one row genet. Even input dat additional columns, included output trackSpp aggByGenet = TRUE, since uncertain can summed across ramets identical across ramets. example, ramet unique character string column called “name”, easy way “sum” character strings column one value genet. want output data frame trackSpp() columns input dat data.frame, set aggByGenet argument FALSE. However, Careful, since demographic analysis done data.set one row per genet, otherwise estimating survival growth rates scale ramets instead genets. take aggByGenet = FALSE route, sure pass dataset aggregateByGenet() function (aggregate genet scale using preferred method) demographic analysis. species/site/quad/year/geometry arguments need included columns dat contain data species, site, quadrat, year geometry observation different names “Species”, “Site”, “Quad”, “Year, ”geometry“. example, column version dat contains species identity observation called”species_names\", argument species = \"species_names\" must included call trackSpp(). printMessages optional logical argument determines whether function returns messages genet aggregation, well messages indicating year last year sampling quadrat year(s) come gap sampling exceeds dorm argument (thus years data “NA” “survives_tplus1” “size_tplus1”). printMessages = TRUE (default), messages printed. printMessages = FALSE, messages printed. flagSuspects optional logical argument length 1, indicating whether observations “suspect” flagged. default flagSuspects = FALSE. flagSuspects = TRUE, column called “Suspect” added output data.frame. suspect observations get “TRUE” “Suspect” column, non-suspect observations receive “FALSE”. two ways observation can classified “suspect”. First, two consecutive observations trackID, observation year t+1 less certain percentage (defined shrink arg.) observation year t, possible observation year t+1 new recruit individual. second way observation can classified “suspect” small going dormant. unlikely small individual survive dormancy, possible function mistakenly given survival value “1” individual. “small individual” observation area certain percentile (specified dormSize) size distribution species, generated using size data species dat. using output dataset demographic analysis, may want exclude “Suspect” observations. flagSuspects = FALSE, additional column added. shrink optional argument takes single numeric value. value used flagSuspects = TRUE. two consecutive observations trackID, ratio size_t+1 size_t smaller value shrink, observation year t gets “TRUE” “Suspect” column. example, shrink = 0.2, individual tracking function identified “BOUGRA_1992_5” area 9 cm\\(^2\\) year_t area 1.35 cm\\(^2\\) year_t+1. ratio size_t+1 size_t 1.35/9 = 0.15, smaller cutoff specified shrink, observation “BOUGRA_1992_5” year t gets “TRUE” “Suspect” column. default value shrink = 0.10. dormSize optional argument takes single numeric value. value used flagSuspects = TRUE dorm ≥ 1. individual flagged “suspect” “goes dormant” size less equal percentile size distribution species designated dormSize. example, dormSize = 0.05, individual basal area 0.5 cm\\(^2\\). 5th percentile distribution size species, made using mean standard deviation observations dat species question, 0.6 cm\\(^2\\). individual overlaps next year (year_t+1), overlap year_t+2. However, basal area observation smaller 5th percentile size species, observation year t get “TRUE” “Suspect” column. possible tracking function mistakenly assigned “1” survival year_t, unlikely individual large enough survive dormancy. default value dormSize = .05. possible arguments trackSpp()!","code":"#>   Species dorm #> 1  tree A    0 #> 2 shrub B    0 #> 3  tree C    0 #> 4  forb D    1 #> 5  forb E    2 #> 6  forb F    1"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"function-output","dir":"Articles","previous_headings":"2 Track individuals through time using trackSpp()","what":"2.2 Function output","title":"Suggested `plantTracker` Workflow","text":"example potential function call trackSpp(), using example dat inv data ’ve used far. : ’s output call trackSpp() looks like: allow species clonal (clonal = 0) aggByGenet = TRUE call trackSpp(), output data frame one row genet, ready demographic analysis! output data frame yet aggregated genet (.e. use aggByGenet = FALSE), need transform data frame genet represented one row data. can use aggregateByGenet() function plantTracker (see function’s documentation guidance), method choice. can stop proceed analyses using demographic data generated, can proceed plantTracker functions outlined additional useful data.","code":"datTrackSpp <- plantTracker::trackSpp(dat = dat, inv = inv,          dorm = 1,          buff = .05,          buffGenet = .005,          clonal = data.frame(\"Species\" = c(\"Heteropogon contortus\",                                            \"Bouteloua rothrockii\",                                            \"Ambrosia artemisiifolia\",                                            \"Calliandra eriophylla\"),                              \"clonal\" = c(TRUE,TRUE,FALSE,FALSE)),          aggByGenet = TRUE,          printMessages = FALSE          ) #> Simple feature collection with 331 features and 12 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.0002186041 xmax: 1.000536 ymax: 1.000651 #> CRS:           NA #> First 10 features: #>    Site Quad                 Species        trackID Year  type    basalArea #> 1    AZ  SG2 Ambrosia artemisiifolia  AMBART_1922_1 1922 point 2.461883e-05 #> 2    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_10 1922 point 2.461883e-05 #> 3    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_11 1922 point 2.461883e-05 #> 4    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_12 1922 point 2.461883e-05 #> 5    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_13 1922 point 2.461883e-05 #> 6    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_14 1922 point 2.461883e-05 #> 7    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_15 1922 point 2.461883e-05 #> 8    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_16 1922 point 2.461883e-05 #> 9    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_17 1922 point 2.461883e-05 #> 10   AZ  SG2 Ambrosia artemisiifolia AMBART_1922_18 1922 point 2.461883e-05 #>    recruit survives_t+1 age size_t+1 nearEdge                       geometry #> 1       NA            0  NA       NA     TRUE POLYGON ((0.350604 0.021361... #> 2       NA            0  NA       NA    FALSE POLYGON ((0.7172048 0.25834... #> 3       NA            0  NA       NA    FALSE POLYGON ((0.1845598 0.38566... #> 4       NA            0  NA       NA    FALSE POLYGON ((0.759387 0.399850... #> 5       NA            0  NA       NA    FALSE POLYGON ((0.1696044 0.40291... #> 6       NA            0  NA       NA    FALSE POLYGON ((0.7290925 0.41097... #> 7       NA            0  NA       NA    FALSE POLYGON ((0.6255546 0.45737... #> 8       NA            0  NA       NA    FALSE POLYGON ((0.5872073 0.46925... #> 9       NA            0  NA       NA    FALSE POLYGON ((0.8863168 0.52256... #> 10      NA            0  NA       NA    FALSE POLYGON ((0.5212498 0.52831..."},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"calculate-local-neighborhood-density-using-getneighbors","dir":"Articles","previous_headings":"","what":"3 Calculate local neighborhood density using getNeighbors()","title":"Suggested `plantTracker` Workflow","text":"often useful demographic analyses idea competition (facilitation) individual organism dealing . Interactions individuals can profound impact whether organism survives grows. Spatial datasets plant occurrence allow us generate estimate interactions individual plant plants determining many individuals occupy “local neighborhood” focal plant. isn’t direct measure competition facilitation, gives us estimate can include demographic models. generic getNeighbors() function:","code":"getNeighbors(dat, buff, method, compType = \"allSpp\", output = \"summed\",   trackID = \"trackID\", species = \"Species\", quad = \"Quad\", year = \"Year\",   site = \"Site\", geometry = \"geometry\", ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"function-options-and-arguments","dir":"Articles","previous_headings":"3 Calculate local neighborhood density using getNeighbors()","what":"3.1 Function options and arguments","title":"Suggested `plantTracker` Workflow","text":"getNeighbors() function plantTracker calculates local neighborhood density unique individual dataset. user-specified buffer drawn around individual, function counts number plants within buffer.function can run dataset unique individual (genet) represented one row data. genet consists multiple polygons, must aggregated one sf MULTIPOLYGON object. dataset multiple rows genet, can use aggregateByGenet() function get ready use getNeighbors(). Additionally, getNeighbors() requires dataset column containing unique identifier genet. Across multiple years, genet must unique identifier. using function right trackSpp(), dataset already unique identifier column called “trackID”. getNeighbors() several options allow customize local neighborhood density calculated. First, user can decide function “counts” plants inside buffer zone around focal individual. Option 1) function tally number genets inside buffer zone. Option 2) function calculate proportion buffer zone occupied plants. Second, user can decide whether function calculate intraspecific local neighborhood density (consider plants buffer zone species focal individual) interspecific local neighborhood density (consider plants buffer zone, regardless species). Third, user can decide whether neighborhood density value (either count area) focal individual single value sums number area neighbors, whether actually list provides neighborhood density species present neighborhood. Figure 3.1: individual outlined pink focal individual, pale pink shows 10 cm buffer around . Figure 3.2: 10cm buffer around focal individual overlaps 5 unique individuals two species. overlapping individuals outlined dark grey. Using ‘count’ method getNeighbors(), get intraspecific competition value 3, interspecific competition value 5. Figure 3.3: 10cm buffer around focal individual overlaps 5 unique individuals two species. overlapping area shaded grey. Using ‘area’ method getNeighbors(), get intraspecific competition metric 0.0454, interspecific competition metric 0.0462. arguments getNeighbors() function. dat sf data frame row represents data unique individual organism unique year. sf geometry row must either MULTIPOLYGON POLYGON geometry. addition “geometry” column, data frame must columns contain data indicating site, quadrat, site, year observation. also must column contains unique identifying value genet year. dat coming directly trackSpp(), column called “trackID”. buff single numeric value indicates desired width “buffer” around focal individual competitors counted. value must units spatial information dat. method character string must equal either \"count\" \"area\". method = \"count\", number individuals buffer area tallied. method = \"area\", proportion buffer area occupied individuals calculated. compType character string must either \"allSpp\" \"oneSpp\". compType = \"allSpp\", metric interspecific competition calculated, meaning every individual within buffer around focal individual considered, matter species. compType = \"oneSpp\", metric intraspecific competition calculated, meaning individuals species focal individual considered calculating competition metric. value provided, default “allSpp”. output character string set either \"summed\" \"bySpecies\". default \"summed\". argument important consider using compType = \"allSpp\". output = \"summed\", one count/area value returned individual. value total count area neighbors within focal species buffer zone, regardless species. output = \"bySpecies\", count area value returned species present buffer zone. example, using getNeighbors() method = \"count\" compType = \"allSpp\". focal individual dataset seven plants inside buffer zone, three species , two species B, 2 species C. output = \"summed\", value “neighbors_count” column returned data frame simply contain value “7”. output = \"bySpecies\", “neighbors_count” column individual actually contain named list {r} list(\"Species \"= 5, \"Species B\" = 3, \"Species C\" = 7). default value output \"summed\". trackID/species/quad/year/site/geometry arguments need included columns dat contain data trackID, species, site, quadrat, year geometry observation different names “trackID,”Species“,”Site“,”Quad“,”Year, “geometry”. example, column version dat contains species identity observation called “species_names”, argument species = \"species_names\" must included call getNeighbors().","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"function-outputs","dir":"Articles","previous_headings":"3 Calculate local neighborhood density using getNeighbors()","what":"3.2 Function outputs","title":"Suggested `plantTracker` Workflow","text":"output getNeighbors() sf data frame identical input dat, either one two additional columns. method = \"area\", two columns added called “nBuff_area” “neighbors_area”. first contains area buffer zone around focal individual. second contains basal area neighbors overlap focal individual’s buffer zone. method = \"count\", one additional column added output, called “neighbors_count.” column contains count neighbors occur within focal individual’s buffer zone. ’s example getNeighbors() function call using resulting data example section 2.2, well resulting data frame. Note method = \"area\", two columns added returned data frame: example uses option output = \"summed\", default getNeighbors() function. option, “neighbors_area” “neighbors_count” column (depending method argument) contains just one value sums neighbor count area across neighbor species. However, output = \"bySpecies\", “neighbors_count” “neighbors_area” column contains list counts areas broken species. output argument described detail section 3.1. want use getNeighbors() function determine effect neighbors differs according species identity neighbors, setting output = \"bySpecies\" allows . However, likely subsequent analyses need -species neighbor data matrix data frame format, rather list nested inside data frame, getNeighbors() returns data. code turns data returned getNeighbors(output = \"bySpecies\") matrix row data one focal individual, column data one species. format easier work analysis.","code":"datNeighbors <- plantTracker::getNeighbors(dat = datTrackSpp,              buff = .15,              method = \"area\",              compType = \"allSpp\") #> Simple feature collection with 331 features and 14 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.0002186041 xmax: 1.000536 ymax: 1.000651 #> CRS:           NA #> First 10 features: #>                    Species Site Quad        trackID Year neighbors_area #> 1  Ambrosia artemisiifolia   AZ  SG2  AMBART_1922_1 1922   0.0011328591 #> 2  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_10 1922   0.0040518140 #> 3  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_11 1922   0.0055774468 #> 4  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_12 1922   0.0029129080 #> 5  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_13 1922   0.0050297901 #> 6  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_14 1922   0.0037646754 #> 7  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_15 1922   0.0026270846 #> 8  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_16 1922   0.0013297048 #> 9  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_17 1922   0.0022690175 #> 10 Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_18 1922   0.0006338116 #>    nBuff_area basalArea basalArea_genet survives_t+1 survives_tplus1 size_t+1 #> 1  0.04320540     point    2.461883e-05           NA               0       NA #> 2  0.07329218     point    2.461883e-05           NA               0       NA #> 3  0.07329218     point    2.461883e-05           NA               0       NA #> 4  0.07329218     point    2.461883e-05           NA               0       NA #> 5  0.07329218     point    2.461883e-05           NA               0       NA #> 6  0.07329218     point    2.461883e-05           NA               0       NA #> 7  0.07329218     point    2.461883e-05           NA               0       NA #> 8  0.07329218     point    2.461883e-05           NA               0       NA #> 9  0.06848976     point    2.461883e-05           NA               0       NA #> 10 0.07329218     point    2.461883e-05           NA               0       NA #>    size_tplus1 nearEdge                       geometry #> 1           NA     TRUE POLYGON ((0.350604 0.021361... #> 2           NA    FALSE POLYGON ((0.7172048 0.25834... #> 3           NA    FALSE POLYGON ((0.1845598 0.38566... #> 4           NA    FALSE POLYGON ((0.759387 0.399850... #> 5           NA    FALSE POLYGON ((0.1696044 0.40291... #> 6           NA    FALSE POLYGON ((0.7290925 0.41097... #> 7           NA    FALSE POLYGON ((0.6255546 0.45737... #> 8           NA    FALSE POLYGON ((0.5872073 0.46925... #> 9           NA    FALSE POLYGON ((0.8863168 0.52256... #> 10          NA    FALSE POLYGON ((0.5212498 0.52831... # save the output of the getNeighbors() function datNeighbors_bySpp <- plantTracker::getNeighbors(dat = datTrackSpp,              buff = .15, method = \"area\", compType = \"allSpp\", output = \"bySpecies\")  # determine all of the possible species that can occupy the buffer zone compSpp <- unique(datTrackSpp$Species)  temp <- lapply(X = datNeighbors_bySpp$neighbors_area,  FUN = function(x) {   tmp <- unlist(x)   tmp2 <- tmp[compSpp]   } )  for (i in 1:length(temp)) {   # fix the column names   names(temp[[i]]) <- compSpp   # save the data in a matrix   if (i == 1) {     datOut <- temp[[i]]   } else {     datOut <- rbind(datOut, temp[[i]])   } } # make the rownames of the matrix correspond to the trackID of the focal individual rownames(datOut) <- datNeighbors_bySpp$trackID  # show the first few rows of the datOut data frame:  datOut[1:5,] #>                Ambrosia artemisiifolia Bouteloua rothrockii #> AMBART_1922_1             4.923767e-05         5.216672e-04 #> AMBART_1922_10            8.437672e-05         1.250163e-03 #> AMBART_1922_11            2.461883e-05         2.310445e-04 #> AMBART_1922_12            9.353468e-05         7.408342e-04 #> AMBART_1922_13            2.461883e-05         1.906272e-08 #>                Calliandra eriophylla Heteropogon contortus #> AMBART_1922_1                     NA          0.0005619542 #> AMBART_1922_10                    NA          0.0027172740 #> AMBART_1922_11                    NA          0.0053217835 #> AMBART_1922_12                    NA          0.0020785392 #> AMBART_1922_13                    NA          0.0050051522"},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Suggested_plantTracker_Workflow.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"4 Next steps","title":"Suggested `plantTracker` Workflow","text":"point, dataset ready use applications wish! additional functions may help analyses, outlined section. Calculate recruitment species--plot--year: getRecruits() function Calculate population rate increase (lambda) species plot: getLambda() function Calculate basal area species quadrat year: getBasalAreas() function Make maps quadrats time: drawQuadMap() function Specific instructions use functions can found documentation!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the `plantTracker` `trackSpp()` function","text":"vignette gives detailed information trackSpp() function, main “workhorse” function plantTracker R package. trackSpp() transforms data set annual maps plant occurrence demographic data set. accomplish , function compares maps across sampling years assigns unique identifiers (“trackIDs”) plants overlap year year. Plants trackID assumed individual. trackIDs used assign survival, growth, recruit status, age individual plant year. process complex requires certain assumptions, following pages explain illustrate logic steps. recommend read vignette using trackSpp() order fully understand assumptions inherent function, make sure adjusting user-specified arguments correctly.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"input-data","dir":"Articles","previous_headings":"","what":"1 Input data","title":"Using the `plantTracker` `trackSpp()` function","text":"required inputs trackSpp() function explained detail Suggested plantTracker Workflow, Parts 1.1, 1.2, 2, well “help” file function (can access typing ?trackSpp R console). However, ’ll include short description arguments :  0.10  Throughout vignette, ’ll use smaller subset grasslandData grasslandInventory data sets included plantTracker examples. subset grasslandData referred dat, dat argument trackSpp(). subset grasslandInventory referred inv, since used inv argument. first rows dat data set ’ll using: maps one quadrat dat first several years sampling: Figure 1.1: Spatial map subset example dat data set","code":"#> Simple feature collection with 6 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -0.000160084 ymin: 0.4334812 xmax: 0.286985 ymax: 0.9419673 #> CRS:           NA #>                 Species Type Site Quad Year sp_code_6 #> 1 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 2 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 3 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 4 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 5 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 6 Heteropogon contortus poly   AZ  SG2 1922    HETCON #>                         geometry #> 1 POLYGON ((0.237747 0.908835... #> 2 POLYGON ((0.2833037 0.85959... #> 3 POLYGON ((0.008583123 0.449... #> 4 POLYGON ((0.1480142 0.46983... #> 5 POLYGON ((0.03573306 0.5259... #> 6 POLYGON ((0.2441894 0.52689..."},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"iterate-through-sites-quadrats-and-species","dir":"Articles","previous_headings":"","what":"2 Iterate through sites, quadrats, and species","title":"Using the `plantTracker` `trackSpp()` function","text":"first step trackSpp() iterating dat first site, quadrat, species. inv also filtered single vector sequential sampling years quadrat question. trackSpp() gets appropriate dorm, clonal, buff, buffGenet arguments given species, either using globally-specified value trackSpp() function call, extracting species-level value argument given data frame unique values species. , data arguments passed assign() function. function exported plantTracker, code can accessed typing plantTracker:::assign() console. remainder vignette describes process assign() function.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"track-individuals-over-time-using-the-assign-function","dir":"Articles","previous_headings":"","what":"3 Track individuals over time using the assign() function","title":"Using the `plantTracker` `trackSpp()` function","text":"input data filtered one site, one quadrat, one species, assign() function used track individuals time. vignette, use data site “AZs”, quadrat “SG2”, species “Heteropogon contortus”. inv vector quadrat c(1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934)","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"get-data-for-the-first-year-of-sampling","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function","what":"3.1 Get data for the first year of sampling","title":"Using the `plantTracker` `trackSpp()` function","text":"data subset yet , time first year observations species quadrat, stored data frame called tempPreviousYear. example, data 1922 stored data.frame.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"group-genets-together-using-groupbygenet-and-assign-trackids-to-each-individual-in-the-first-year-of-sampling","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function","what":"3.2 Group genets together using groupByGenet, and assign “trackIDs” to each individual in the first year of sampling","title":"Using the `plantTracker` `trackSpp()` function","text":"first year sampling, polygons grouped genets (clonal = TRUE), none assigned trackIDs. tasks accomplished function called ifClonal(), internal assign(). clonal = FALSE, clonality allowed, polygon assumed represent unique genet. case, polygon/row tempPreviousYear assigned unique “genetID” acts temporary identifier used later function. clonal = TRUE, clonality allowed, possible multiple polygons/rows raw data represent one genetic individual. case, use function called groupByGenet() group polygons together one genet. function uses buffGenet argument supplied trackSpp(). distance (buffGenet x 2) maximum distance two polygon edges can one another still considered ramets genet. words, two polygons edges less (buffGenet x 2) one another get “genetID.” groupByGenet() creates matrix distances every single polygon present input data.frame, clusters together based proximities threshold indicated buffGenet. , basal area summed ramets stored “basalArea_genet” column tempPreviousYear. Also, temporary genetIDs assigned, permanent “trackID” given genet. combination six letter species code, year first observation, arbitrary index differentiating individuals species year recruitment (e.g. HETCON_1922_3). following figure shows data one year (1922) one species (Heteropogon contortus). Figure 3.1: value ‘buffGenet’ used trackSpp() function can make big difference genetID assignments. examples move genet grouping left, every polygon genetID, grouping ramets together less 10 cm apart right. Colors numbers indicate different genetIDs. Buffers drawn around ramets belong genet.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"assign-age-and-recruitment-data-to-first-year","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function","what":"3.3 Assign age and recruitment data to first year","title":"Using the `plantTracker` `trackSpp()` function","text":"can also give individuals first year data “age” “recruit” columns. first year data dat actually first year quadrat sampled (e.g. Heteropogon contortus observations 1922, quadrat SG2 first sampled 1922), put “NA” “age” “recruitment” columns. data collected previous year, don’t know plants new recruits, don’t know age. first year data dat – now tempPreviousYear– first year quadrat sampled (e.g. first Heteropogon contortus observations 1924, quadrat SG2 first sampled 1922), know individuals tempPreviousYear really new recruits first year, present previous year. get “1” “recruit” “age” columns. first year data dat also last year quadrat sampled (e.g. first Heteropogon contortus observations 1934, last year sampling), observations tempPreviousYear get “1” “recruit” “age” columns, also get “NA” “size_tplus1” “survives_tplus1” columns. case, assign() function still uses ifClonal() assign genetIDs observations assigns trackIDs. steps needed generate demographic data, function returns tempPreviousYear result point.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"compare-sequential-years-of-data-to-track-individuals-through-time","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function","what":"3.4 Compare sequential years of data to track individuals through time","title":"Using the `plantTracker` `trackSpp()` function","text":"Now comes main work function, compares quadrat maps species time, assigns trackID polygons overlap year year. accomplished using loop compares previous year data current year data. loop iterates year index . “previous” year year index -1 inv vector, associated data stored tempPreviousYear data.frame. “current” year year index inv vector, associated data stored tempCurrentYear data.frame. multiple -else statements nested within larger loop, ’ll explain using dichotomous key .","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"is-there-a-gap-between-year-i-1-and-year-i","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.1 Is there a gap between year i-1 and year i?","title":"Using the `plantTracker` `trackSpp()` function","text":"every quadrat sampled every year, indicated inv vector. one case dorm argument input trackSpp() passed assign() comes . value dorm indicates many years “acceptable” plant disappear quadrat maps still considered individual trackID. value dorm must determined user, represents point ’s necessary biological knowledge species present data set. example, allowing dormancy makes sense species perennial forbs, doesn’t large organisms trees. trackSpp() allows specify dorm argument globally one value, individually species. dorm argument can also way control “forgiving” want data set. example, expect plants sometimes missed mapping digitization process, allowing dormancy value “1” help account . ’s important realize using dorm value “1” higher likely slightly overestimate growth survival, using value “0” likely slightly underestimate growth survival.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"get-data-for-year-i","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.2 Get data for year i","title":"Using the `plantTracker` `trackSpp()` function","text":"already data “previous” year (inv[-1]) stored tempPreviousYear. Now know gap years doesn’t exceed dorm, can get data “current” year (inv[]). subsetting dat observations year inv[]. , use ifClonal() group closely-grouped polygons genets applicable, assign genetIDs. data set stored tempCurrentYear data.frame. Proceed step 3.4.3.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"are-there-any-observations-in-the-previous-year-invi-1","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.3 Are there any observations in the “previous” year (inv[i-1])?","title":"Using the `plantTracker` `trackSpp()` function","text":"Even quadrat sampled inv[-1], possible weren’t actually plants year.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"add-a-buffer-around-the-previous-year-data","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.4 Add a buffer around the “previous” year data","title":"Using the `plantTracker` `trackSpp()` function","text":"Now buffer added around polygon tempPreviousYear. data stored tempPreviousBuff data.frame. buffer width specified buff argument trackSpp() passed assign(). Adding buffer comparing maps previous current years allows mapping error slight movement plants years, especially likely forbs resprout every year. Proceed step 3.4.5. Figure 3.2: 10 cm buffer, polygons 1922 1923 overlap identified trackSpp() individual receive trackID. Figure 3.3: 5 cm buffer, polygons 1922 1923 overlap identified trackSpp() different individuals receive different trackIDs.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"are-there-actually-any-observations-in-the-current-year-invi","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.5 Are there actually any observations in the “current” year (inv[i])?","title":"Using the `plantTracker` `trackSpp()` function","text":"Even quadrat sampled inv[], possible weren’t actually plants year.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"store-observations-as-ghosts-to-compare-to-data-from-the-next-year-invi1-during-the-next-iteration-of-the-loop-","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.6 Store observations as “ghosts” to compare to data from the next year (inv[i+1]) during the next iteration of the loop.","title":"Using the `plantTracker` `trackSpp()` function","text":"step also involves “dormancy” concept discussed section [3.4.1]. dormancy allowed species (.e. dorm = 0), observations question “sent” step must given “0” “survives_tplus1” column “NA” “size_tplus1” column. allowed dormant, don’t overlapping individuals current year (inv[])–don’t ’re sent step–’re dead. Take observations step 3.4.11. However, dormancy allowed species, individuals “sent” step didn’t overlap anything year inv[] can “stored” compared next set data year +1. call stored individuals “ghosts.” ghosts compared polygons year +1, +2, etc. way dormancy argument exceeded. example, Heteropogon contortus individuals present 1922, overlap plants 1923 dorm = 1, stored “ghosts” locations together individuals 1923 compared mapped individuals 1924. “ghosts” matches 1924 data, get “0” “survives_tplus1” column since allowed dormant one year. call individuals “dead ghosts.” observations sent step, observed year greater 1 + dorm years ago, become “dead ghosts.” “dead ghosts” added output data.frame. “ghosts” saved next step, 3.4.12 Figure 3.4: visualization ‘dormancy’ scenario described . observation 1922 overlap observation 1923 (panels 1 2). However, ‘dorm’ greater equal 1, can save 1922 observation ‘ghost’ (illustrated dotted border panel 2). compared observations 1924, overlap! ‘dorm’ = 1 (), observation 1922 get ‘1’ ‘survives_tplus1’ column. ‘dorm’ = 0, observation 1922 get ‘0’ survival, observation 1924 new recruit.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"are-there-any-overlaps-between-polygons-in-temppreviousyear-and-tempcurrentyear","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.7 Are there any overlaps between polygons in tempPreviousYear and tempCurrentYear?","title":"Using the `plantTracker` `trackSpp()` function","text":"Use st_intersection function sf package determine overlap polygons previous year (inv[-1], stored intempPreviousYear) current year (inv[], stored tempCurrentYear).","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"compare-the-overlap-between-temppreviousyear-and-tempcurrentyear-to-assign-trackids-","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.8 Compare the overlap between tempPreviousYear and tempCurrentYear to assign trackIDs.","title":"Using the `plantTracker` `trackSpp()` function","text":"st_intersection function used step 3.4.7 returns matrix gives total area overlap genet tempPreviousYear genet tempCurrentYear (“overlap matrix”). two options , depending clonal = TRUE FALSE. clonal = TRUE, “parent” (tempPreviousYear) can represented one polygon. However, polygons part genet trackID. “Child” polygons (tempCurrentYear) yet grouped genet, trackIDs assigned. “overlap matrix” aggregated parent trackID parent trackID one row matrix. “overlap matrix” column potential child polygon. “child” polygon (tempCurrentYear) can one parent trackID (can multiple parent polygons). “parent” (tempPreviousYear) can multiple child polygons. words, row (parent) “overlap matrix” allowed overlap values one column, column (child) matrix can one overlap value. column overlap matrix one overlap value, next step straightforward. overlapping “child” polygon given trackID ’s “parent” tempCurrentYear data frame. multiple “children” overlap parent, children considered ramets genet. , however, “child” overlaps multiple parents (.e. column values one row), need determine potential “parent” likely true parent. “tie” first broken comparing overlap area. true “parent” parent highest degree overlap “child”. rare case tie overlap area, parent polygon centroid closest centroid child polygon identified true “parent”. values child column turned “NA”s. clonal = FALSE, “child” can one “parent”, “parent” one “child”. case, assign() function uses loop look matrix generated step 3.4.7. highest value matrix indicates greatest degree overlap given “parent” “child.” trackID parent given child. , overlap values entire “parent” row “child” columns overlap matrix changed zero, since parent can one child child can one parent. loop repeats process finding highest value matrix assign trackIDs entire matrix non-zero values left. Take tempCurrentYear (child) tempPreviousYear (parent) data frames step 3.4.9. Figure 3.5: data Heteropogon contortus* 1922 1923. 5 cm buffer shown around genet 1922. Data years grouped genet using ‘buffGenet’ = .01* Figure 3.6: buffered data Heteropogon contortus 1922, overlapped data 1923. Figure 3.7: trackID assignments two years data. trackID different color different number.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"flag-any-suspect-observations","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.9 Flag any suspect observations","title":"Using the `plantTracker` `trackSpp()` function","text":"flagSuspects = FALSE, proceed directly step 3.4.10. flagSuspects = TRUE, following checks take place. first check identifies flags individuals previous year became substantially smaller current year. example, two overlapping observations consecutive years function given trackID. observation previous year basal area 20 cm\\(^2\\), observation current year basal area 1.5 cm\\(^2\\). possible two fact individual, also possible observation current year new recruit happens similar location larger plant previous year. flagSuspects = TRUE, individual previous year (“parent”) basal area current year certain percentage size get “TRUE” “Suspect” column. threshold defined shrink argument, default value 0.10 (10%). use previous example, shrink = .10, individual basal area 20 cm\\(^2\\) previous year flagged “suspect” shrunk 10% size. second check flags small individuals go dormant. check used dorm argument set “1” higher, observations measured polygons. check can’t used observations measured points converted small polygons fixed size, since don’t know plant’s true size. plant small basal area unlikely actually survive dormancy. possible tracking function correctly given trackID small individual present year 1, absent year 2, present year 3. However, also possible small individual died, observation year 3 new recruit. check puts TRUE “suspect” column “parent” individual “survives” dormancy certain percentile size distribution species (created using size data species provided dat). percentile threshold defined dormSize argument, default value 0.05 (5%). checks complete, tempCurrentYear (child) tempPreviousYear (parent) data frames go step 3.4.10. important note , even though checks flag individuals whose trackID assignment might “suspect”, trackSpp() function still proceeds flagSuspects set FALSE. user whether want exclude “suspect” observations subsequent analyses. exclude observations, possible slightly overestimate survival, underestimate recruitment growth.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"separate-the-ghosts-and-the-new-recruits-from-the-parent-and-child-data-frames","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.10 Separate the “ghosts” and the new recruits from the “parent” and “child” data frames","title":"Using the `plantTracker` `trackSpp()` function","text":"Figure 3.8: visualization observations broken ‘parents’, ‘ghosts’, ‘children’, ‘orphans’. ghosts data frame sent step 3.4.6. observations parents data frame get “1” “survives_tplus1” column, total genet area “child” put “size_tplus1” column. , parents data frame sent step 3.4.11 observations children data frame get “0” “recruit” column, age column populated 1 + age parent. observations orphans data frame get “1” “recruit” column “1” “age” column. However orphans occur gap sampling, instead get “NA” “recruit” “age” columns, since don’t know whether recruited year gap. , children orphans data.frames sent step 3.4.12.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"store-the-resulting-demographic-data","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.11 Store the resulting demographic data","title":"Using the `plantTracker` `trackSpp()` function","text":"Now demographic data (NAs, appropriate) trackIDs assigned every individual tempPreviousYear (actually observations inv[-1]), can save results. added data frame , loop finishes, returned assign() function. “dead ghosts”, also added output data.frame. inv[] last year sampling, proceed step 3.4.12. inv[] last year sampling, loop !","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"get-ready-for-the-next-iteration-of-the-loop","dir":"Articles","previous_headings":"3 Track individuals over time using the assign() function > 3.4 Compare sequential years of data to track individuals through time","what":"3.4.12 Get ready for the next iteration of the loop","title":"Using the `plantTracker` `trackSpp()` function","text":"still iterations loop left, inv[] last year inv, data year[] (stored either tempCurrentYear children orphans) ‘ghosts’ previous years put tempPreviousYear data.frame. happens even tempCurrentYear empty. already genetIDs assigned data inv[] tempCurrentYear (happens first year gap sampling), passed ifClonal(). loop proceeds next value (start section 3.4.1). loop progressed ‘last’ year, output data set saved, next species data set sent assign()!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"prepare-the-trackspp-results-to-be-returned","dir":"Articles","previous_headings":"","what":"4 Prepare the trackSpp() results to be returned!","title":"Using the `plantTracker` `trackSpp()` function","text":"just steps trackSpp() assign() function applied every species present data set.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"aggregate-the-results-by-genet","dir":"Articles","previous_headings":"4 Prepare the trackSpp() results to be returned!","what":"4.1 Aggregate the results by genet","title":"Using the `plantTracker` `trackSpp()` function","text":"data.frames returned assign() function exact length input data frames. means , even though trackIDs demographic data assigned genet level, ‘observation’, ramet, row data. trackSpp() argument aggByGenet = TRUE, output data set passed aggregateByGenet() function plantTracker. aggregates data set genet year represented one row data. polygons ramet combined one spatial object using st_union function sf package. resulting data frame shorter narrower input data.frame, since rows combined. output assign() function contains column “basalArea_ramet”, column longer present results aggregated. columns input data frame beyond required (Species, Site, Quad, Year, geometry), dropped also, since function can’t predict whether possible aggregate genet level. input data frame data additional columns can aggregated want keep demographic data, recommend using aggByGenet = FALSE. want ultimately aggregate demographic data genet, can use sf::aggregate function , modify code aggregateByGenet() function include additional columns. set clonal = FALSE species input data.frame, also recommend using aggByGenet = FALSE, since results already genet scale!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"informative-messages","dir":"Articles","previous_headings":"4 Prepare the trackSpp() results to be returned!","what":"4.2 Informative messages","title":"Using the `plantTracker` `trackSpp()` function","text":"argument printMessages = TRUE, one two messages printed species goes assign() function. messages warnings errors! Unless function returns message preceded word “warning” “error”, function working! messages ’m talking provide information “NA”s present demographic results, may concerning aren’t expecting . first message tells year last year sampling quadrat. Observations last year sampling “NA” “survives_tplus1” “size_tplus” columns data determine whether survived. second message appears gap sampling quadrat exceeds dorm argument. message indicates observations year(s) preceding gap “NA”s “survives_tplus1” “size_tplus1” columns, since don’t know died. printMessages = TRUE aggByGenet = TRUE, additional message printed. message warn output data frame shorter narrower input data.frame, explain . Lastly, printMessages = TRUE, trackSpp() function print progress messages indicate site run function, species, quadrat. helpful know far function gotten data, also helpful function errors . can find roughly problem data , since know species, quadrat, site function crashed. printMessages = FALSE, messages returned.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/articles/Using_the_plantTracker_trackSpp_function.html","id":"examples","dir":"Articles","previous_headings":"","what":"5 Examples","title":"Using the `plantTracker` `trackSpp()` function","text":"Figure 5.1: trackID assignments 4 years data. trackID shown different color different number. Figure 5.2: trackID assignments 4 years data. trackID shown different color different number. Figure 5.3: trackID assignments 4 years data. trackID shown different color different number.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alice Stears. Author, maintainer. Jared Studyvin. Author. David Atkins. Author. Peter Adler. Contributor. Shannon Albeke. Contributor. Daniel Laughlin. Contributor, thesis advisor.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Stears AE, Adler PB, Albeke SE, Atkins DH, Studyvin J, Laughlin DC (2022). “plantTracker: R package translate chart quadrat maps demographic data.” Methods Ecology Evolution (pending). http://github.com/aestears/plantTracker.","code":"@Article{,   title = {plantTracker: an R package to translate chart quadrat maps into demographic data},   author = {Alice E Stears and Peter B Adler and Shannon E Albeke and David H Atkins and Jared Studyvin and Daniel C Laughlin},   journal = {Methods in Ecology and Evolution (pending)},   year = {2022},   url = {http://github.com/aestears/plantTracker}, }"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"planttracker","dir":"","previous_headings":"","what":"Extract Demographic and Competition Data from Fine-scale Maps","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"Welcome plantTracker! package designed transform long-term quadrat maps show plant occurrence size demographic data can used answer questions population community ecology.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of Contents","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"Installing plantTracker Contributing License Contact transform dat sf format quadrat inventory data: inv Ensure data correct format checkDat() Arguments trackSpp() Understanding output trackSpp() Arguments getNeighbors() Understanding output trackSpp() analysis plantTracker functions","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"can install current version plantTracker GitHub : plantTracker also available download form CRAN near future, stay tuned!","code":"install.packages(\"devtools\") devtools::install_github(\"aestears/plantTracker\")"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"Please report problems encounter using plantTracker “issues” (GitHub repository)[https://github.com/aestears/plantTracker/issues]. Help us make package better!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"package licensed MIT License Copyright (c) 2022 Alice Stears","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"Questions plantTracker can forwarded Alice Stears, package maintainer, alice.e.stears@gmail.com.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"how-to-use-the-planttracker-r-package","dir":"","previous_headings":"","what":"How to use the plantTracker R package","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"material explains use plantTracker, starting formatting data correctly. information also available ‘Suggested plantTracker Workflow’ vignette, included package.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"1-prepare-data","dir":"","previous_headings":"How to use the plantTracker R package","what":"1. Prepare data","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"functions plantTracker require data specific format. plantTracker includes example dataset consists two pieces: grasslandData grasslandInventory. can load example datasets global environment calling data(grasslandData) data(grasslandInventory). can view documentation datasets calling?grasslandData ?grasslandInventory. plantTracker functions require two data objects. first data frame contains location metadata mapped individual, now call dat. second list contains vector years quadrat sampled, now cal inv. basic requirements data objects.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"11-the-dat-data-frame-must---","dir":"","previous_headings":"How to use the plantTracker R package > 1. Prepare data","what":"1.1 The dat data frame must . . .","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"… sf data.frame. section 1.1.1… … contain row individual observation year. … column contains character strings indicating specific epithet observation. column must character data type. function expects column called “Species”, different name can specified function calls. … column contains character strings indicating site observation collected. level classification “” quadrat (.e. quadrats measured Central Plains Experimental Range Nunn, CO might value “CO” column). column must character data type. function expects column called “Site”, different name can specified function calls. … column contains character strings indicating quadrat observation collected. column must character data type. function expects column called “Quad”, different name can specified function calls. … column contains value indicating year individual observation collected. must numeric data type, must either four two digit year number. function expects column called “Year”, different name can specified function calls. … column (almost always called “geometry” sf package data format) contains polygon representing location observation. observation must POLYGON MULTIPOLYGON. Data stored POINTS. data collected forbs small grasses mapped points digitized , observations must converted polygons. recommend convert small circular polygons identical radius. transformation, also recommend include column indicates whether row originally mapped polygon point, since demographic data deals size relatively meaningless observations originally mapped points. dat need coordinate reference system (.e. CRS can “NA”), can one ’d like. … columns called “neighbors”, “nearEdge”, “trackID”, “age”, “size_tplus1”, “recruit”, “survives_tplus1”, “basalArea_ramet”, “basalArea_genet”, since columns added plantTracker functions. Note: Additional columns can included input data.frame, although might included output plantTracker functions. first rows possible dat input data.frame: Note: required columns “Species”, “Site”, “Quad”, “Year”, “geometry”. additional columns “Type” “sp_code_6” just “along ride” analysis using plantTracker functions. ’s example dat data (“SG2” quadrat “AZ” site 1922) look like plotted spatially: Figure 1.1 : Spatial map subset example ‘dat’ dataset ’s important note , plantTracker designed used small-scale maps plant occurrence quadrats, conceivably possible use styles map data plantTracker functions. required single mapped basal area (point location converted small polygon) time point organism (ramet), accompanied required metadata detailed . example, plantTracker functions used estimate tree demographic rates scale 100 m x 50 m plots.","code":"#> Simple feature collection with 6 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -0.000160084 ymin: 0.4334812 xmax: 0.286985 ymax: 0.9419673 #> CRS:           NA #>                 Species Type Site Quad Year sp_code_6 #> 1 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 2 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 3 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 4 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 5 Heteropogon contortus poly   AZ  SG2 1922    HETCON #> 6 Heteropogon contortus poly   AZ  SG2 1922    HETCON #>                         geometry #> 1 POLYGON ((0.237747 0.908835... #> 2 POLYGON ((0.2833037 0.85959... #> 3 POLYGON ((0.008583123 0.449... #> 4 POLYGON ((0.1480142 0.46983... #> 5 POLYGON ((0.03573306 0.5259... #> 6 POLYGON ((0.2441894 0.52689..."},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"111-get-your-data-into-the-sf-data-format","dir":"","previous_headings":"How to use the plantTracker R package > 1. Prepare data > 1.1 The dat data frame must . . .","what":"1.1.1 Get your data into the sf data format","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"mentioned , plantTracker uses sf R package deal spatial data. map data plantTracker built analyze inherently spatial, need know basics dealing spatial data R want use plantTracker! many good resources help orient working spatial data R generally: https://cengel.github.io/R-spatial/intro.html https://www.r-bloggers.com/2021/06/using-geospatial-data--r/ sf package specifically: https://cran.r-project.org/web/packages/sf/sf.pdf https://r-spatial.github.io/sf/ resources provide great orientation, recommend looking ’re new working spatial data R, ’ve included brief tutorial uploading shapefiles R sf data frames. published chart-quadrat datasets map data stored shapefiles complex file structures, can bit confusing navigate. plantTracker requires data (species, plots years) one single data frame, code shows navigate complex file structure pull shapefiles put one single sf data frame. example, ’ll use data Central Plains Experimental Research Location Colorado, published data paper. dataset, shapefiles quadrat stored folder. Within folder two shapefiles year: one contains map data polygons, one contains data points. following code reads shapefiles, transforms points polygons fixed radius, puts data one sf data frame. want follow along, download “shapefiles.zip” file data paper, un-zip , name “CO_shapefiles”.","code":"#  save a character vector of the file names in the file that contains the  # shapefiles (in this case, called \"CO_shapefiles\"), each of which is a quadrat # note: 'wdName' is a character string indicating the path of the directory  # containing the 'CO_shapefiles' folder quadNames <- list.files(paste0(wdName,\"CO_shapefiles/\"))  # now we'll loop through the quadrat folders to download the data for (i in 1:2){#length(quadNames)) {   # get the names of the quadrat for this iteration of the loop   quadNow <- quadNames[i]   #  get a character vector of the unique quad/Year combinations of data in    # this folder that contain polygon data   quadYears <- quadYears <-  unlist(strsplit(list.files(     paste0(wdName, \"CO_shapefiles/\",quadNow,\"/\"),     pattern = \".shp$\"), split = \".shp\"))   # loop through each of the years in this quadrat   for (j in 1:length(quadYears)) {     # save the name of this quadYear combo     quadYearNow <- quadYears[j]     # read in the shapefile for this quad/year combo as an sf data frame      # using the 'st_read()' function from the sf package      shapeNow <- sf::st_read(dsn = paste0(wdName,\"CO_shapefiles/\",quadNow),                              #  the 'dsn' argument is the folder that                              # contains the shapefile files--in this case,                              # the folder for this quadrat                             layer = quadYearNow) # the 'layer' argument has the      # name of the shapefile, without the filetype extension! This is because each      # shapefile consists of at least three separate files, each of which has a      # unique filetype extension.      # the shapefiles in this dataset do not have all of the metadata we      # need, and have some we don't need, so we'll remove what we don't need and      # add columns for 'site', 'quad', and 'year'     shapeNow$Site <- \"CO\"     shapeNow$Quad <- quadNow     # get the Year for the shapefile name--in this case it is the last for      # numbers of the name     shapeNow$Year <- as.numeric(strsplit(quadYearNow, split = \"_\")[[1]][4])     # determine if the 'current' quad/year contains point data or polygon data     if (grepl(quadYearNow, pattern = \"^pnt\")) { # if quadYearNow has point data       # remove the columns we don't need       shapeNow <- shapeNow[,!(names(shapeNow)                               %in% c(\"coords_x1\", \"coords_x2\", \"coords_x1_\",                                       \"coords_x2_\", \"coords_x1.1\", \"coords_x2.1\"))]       # reformat the point into a a very small polygon        # (a circle w/ a radius of .003 m)       shapeNow <- sf::st_buffer(x = shapeNow, dist = .003)       # add a column indicating that this observation was originally        # mapped as a point       shapeNow$type <- \"point\"     } else { # if quadYearNow has polygon data       # remove the columns we don't need       shapeNow <- shapeNow[,!(names(shapeNow) %in% c(\"SP_ID\", \"SP_ID_1\", \"x\", \"y\", \"area\"))]       # add a column indicating that this observation was originally        # mapped as a polygon       shapeNow$type <- \"polygon\"     }     # now we'll save this sf data frame      if (i == 1 & j == 1) { # if this is the first year in the first quadrat       outDat <- shapeNow     } else { # if this isn't the first year in the first quadrat, simply rbind        # the shapeNow sf data frame onto the previous data        outDat <- rbind(outDat, shapeNow)     }   } }  # Now, all of the spatial data are in one sf data frame, and are ready to be used in plantTracker functions!"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"12-the-inv-list-must---","dir":"","previous_headings":"How to use the plantTracker R package > 1. Prepare data","what":"1.2 The inv list must . . .","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"… named list … element names character string identical name quadrat dat. two elements name, element one quadrat name. must element quadrat data dat. … list elements numeric vector years quadrat sampled. quadrat “skipped” year, year must excluded vector. format years must format years dat (.e. year four-digit number dat, must four-digit number inv). Make sure years quadrat actually sampled, just years data dat data frame! argument allows function differentiate years quadrat wasn’t sampled years just weren’t individuals species present quadrat. quadrat wasn’t sampled given year, don’t put ‘NA’ inv year! Instead, just skip year. example inv argument corresponds example dat argument . quadrats data dat “SG2” “SG4”, elements inv correspond quadrats. already quadrat inventory data frame, isn’t complicated reformat work plantTracker functions. example, quadrat inventory data frame looks like … : … following get format ready plantTracker:","code":"#> $SG2 #> [1] 1922 1923 1924 1925 1926 1927 #>  #> $SG4 #> [1] 1922 1923 1924 1925 1926 1927 #>   quad1 quad2 quad3 #> 1  2000  2000  2000 #> 2  2001  2001    NA #> 3    NA  2002  2002 #> 4  2003  2003  2003 #> 5  2004  2004  2004 #> 6  2005  2005  2005 #> 7  2006  2006  2006 #> 8  2007  2007  2007 quadInv_DF <- data.frame(\"quad1\" = c(2000, 2001, NA, 2003, 2004, 2005, 2006, 2007),            \"quad2\" = c(2000:2007),             \"quad3\" = c(2000, NA, 2002, 2003, 2004, 2005, 2006, 2007))  # use the 'as.list()' function to transform your data frame into a named list quadInv_list <- as.list(quadInv_DF) # we still need to remove the 'NA' values, which we can do using the  # 'lapply()' function (quadInv_list <- lapply(X = quadInv_list, FUN = function(x) x[is.na(x) == FALSE])) #> $quad1 #> [1] 2000 2001 2003 2004 2005 2006 2007 #>  #> $quad2 #> [1] 2000 2001 2002 2003 2004 2005 2006 2007 #>  #> $quad3 #> [1] 2000 2002 2003 2004 2005 2006 2007"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"13-check-the-inv-and-dat-arguments-using-checkdat","dir":"","previous_headings":"How to use the plantTracker R package > 1. Prepare data","what":"1.3 Check the inv and dat arguments using checkDat()","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"generic checkDat() function: step optional, can useful ’re unsure whether dat inv arguments correct format. plantTracker function checkDat() takes dat inv arguments arguments dat andinv, return informative error messages either argument correct format. Additional optional arguments checkDat() species, site, quad, year, geometry, reformatDat. species/site/quad/year/geometry arguments need included columns dat contain data species, site, quadrat, year geometry observation different names “Species”, “Site”, “Quad”, “Year, ”geometry“. example, column version dat contains species identity observation called”species_names\", argument species = \"species_names\" must included call checkDat(). reformatDat TRUE/FALSE argument determines whether want checkDat() function return version dat ready go steps workflow. reformatDat = TRUE checkDat() return list contains reformatted version dat, reformatted version inv additional element called “userColNames”, contains column names input version dat different expected column names “Species”, “Site”, “Quad”, “Year, ”geometry\" (). reformatDat = TRUE, checkDat() return message indicating data ready next step. default value FALSE.","code":"checkDat(dat, inv = NULL, species = \"Species\", site = \"Site\", quad = \"Quad\",   year = \"Year\", geometry = \"geometry\", reformatDat = FALSE, ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"2-track-individuals-through-time-using-trackspp","dir":"","previous_headings":"How to use the plantTracker R package","what":"2 Track individuals through time using trackSpp()","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"Now ’s time transform raw dataset demographic data! accomplished using trackSpp() function. function follows individual plants year year quadrat determine survival, size next year, age, additional potentially-useful demographic data. comparing quadrat maps sequential years. overlap individuals species consecutive years, rows dat contain data overlapping individuals given “trackID”, unique identifier. generic trackSpp() function:","code":"trackSpp(dat, inv, dorm, buff, buffGenet, clonal, species = \"Species\",   site = \"Site\", quad = \"Quad\", year = \"Year\", geometry = \"geometry\",   aggByGenet = TRUE, printMessages = TRUE, flagSuspects = FALSE,   shrink = 0.1, dormSize = 0.05, ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"21-function-arguments","dir":"","previous_headings":"How to use the plantTracker R package > 2 Track individuals through time using trackSpp()","what":"2.1 Function arguments","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"trackSpp() takes following arguments: dat sf data frame ’ve calling dat far. must correct format (can check -hand using checkDat()), informative error messages returned incorrect. must columns outlined Section 1.1, can different names long names included function call (later…). inv list quadrat sampling years ’ve calling inv. correct format contain data correct quadrats, informative error message returned. dorm positive integer value indicates long want function allow individual “dormant”. case, dormancy can interpreted biological phenomenon plant -ground tissue present year 1, alive underground -ground tissue year 2, -ground tissue subsequent year. Dormancy can also interpreted data-collection error, whereby individual accidentally mapped years recorded. Consider following example: polygon species “” year 1, “focal individual”. year 2, polygon species “” overlaps focal individual. year 3, polygon species “” location focal individual. dorm = 0, focal individual get 0 survival column, polygon species “” year 3 considered new recruit get new trackID. dorm = 1, overlap two polygons species 1-year gap occur, two polygons considered genetic individual, trackID, focal individual “1” survival column. alternative scenario, years 3 4 polygons species “” location focal individual, polygon year 4 overlaps focal individual. dorm = 1, focal individual get “0” survival, dorm = 2, get 1 survival. Figure 2.1: visualization ‘dormancy’ scenario described . ’d like specific perhaps biologically accurate, can also specify dorm argument uniquely species. example, might confident data collectors accidentally “miss” individuals, dat data frame contains observations shrubs trees, unlikely go dormant, small forbs, much likely go dormant one two years. order disallow dormancy trees shrubs, allow dormancy forbs, provide data frame dorm argument instead single positive integer value. two columns: 1) “Species” column species name species present dat, 2) column called “dorm” positive integer values indicating dormancy ’d like allow species. Make sure following data frame approach, must provide dormancy argument every species data dat. Make sure species names dorm data frame spelled exactly dat. data frame look something like : Important Note: careful define dorm argument. bigger dorm argument, likely overestimate survival. annually-sampled data, need biologically-compelling reason specify dorm argument greater 1 year. buff positive numeric value indicates much individual can move year 1 year 2 still considered individual (receive trackID). addition accounting true variation location plant’s stem year year, argument also accounts small inconsistencies mapping year year. buff argument must units spatial values dat. example, spatial data dat measured meters, want allow plant “move” 15 cm year 1 year 2, include argument buff = .15 call trackSpp(). want allow movement, use buff = 0. visualization two different buff scenarios. Figure 2.2: 10 cm buffer, polygons 1922 1923 overlap identified trackSpp() individual receive trackID. Figure 2.3: 3 cm buffer, polygons 1922 1923 don’t quite overlap, identified trackSpp() different individuals receive different trackIDs. clonal logical argument (TRUE FALSE) indicates whether want allow plants clonal . context type data, “clonal” means one genetic individual (“genet”) can recorded multiple polygons (“ramets”). clonal = TRUE, multiple polygons year can part individual trackID. clonal = FALSE, every polygon given year unique individual unique trackID. option can defined globally species present dat setting clonal equal FALSE TRUE trackSpp() function call. Alternatively, clonal can specified uniquely species creating data frame contains clonal argument species (analogous data frame dorm argument shown Table 2.1, column called “clonal”). following arguments trackSpp() required certain contexts. buffGenet argument required clonal = TRUE clonal data frame contains least single TRUE “clonal” column. buffGenet numeric value indicates close polygons species must one another first year order considered parts genetic individual (ramets genet). Similar buff, careful conservative defining argument. large value buffGenet can quickly lead entire quadrat treated genetic individual! suggest experimenting multiple values buffGenet, looking maps show trackID assignment, deciding value leads trackID assignments make biological sense . argument passed groupByGenet() function, assigns trackID individuals within buffGenet buffer . Polygons grouped genet first year data. point, grouping genet happens based data previous years. multiple polygons overlap genet previous year, given trackID considered ramets belonging genet. value buffGenet must greater equal zero, must units spatial data dat. buffGenet can single numeric value applied species present dat, can specified uniquely species creating data frame contains buffGenet argument species (analogous data frame dorm argument shown Table 2.1, column called “buffGenet”). aggByGenet logical argument required clonal = TRUE clonal data frame contains least single TRUE “clonal” column. argument determines whether output data frame trackSpp() row every single ramet, aggregated genet represented single row. aggByGenet = FALSE, output aggregated. aggByGenet = TRUE (default setting), results aggregated using plantTracker function aggregateByGenet(). function combines sf “POLYGONS” ramet one sf MULTIPOLYGON entire genet, combines associated metadata (“Species”, “Site”, “Quad”, “Year”, “trackID”, “basalArea_genet”, “age”, “recruit”, “survives_tplus1”, “size_tplus1”, “nearEdge”) one row genet. Even input dat additional columns, included output trackSpp aggByGenet = TRUE, since uncertain can summed across ramets identical across ramets. example, ramet unique character string column called “name”, easy way “sum” character strings column one value genet. want output data frame trackSpp() columns input dat data.frame, set aggByGenet argument FALSE. However, Careful, since demographic analysis done data.set one row per genet, otherwise estimating survival growth rates scale ramets instead genets. take aggByGenet = FALSE route, sure pass dataset aggregateByGenet() function (aggregate genet scale using preferred method) demographic analysis. species/site/quad/year/geometry arguments need included columns dat contain data species, site, quadrat, year geometry observation different names “Species”, “Site”, “Quad”, “Year, ”geometry“. example, column version dat contains species identity observation called”species_names\", argument species = \"species_names\" must included call trackSpp(). printMessages optional logical argument determines whether function returns messages genet aggregation, well messages indicating year last year sampling quadrat year(s) come gap sampling exceeds dorm argument (thus years data “NA” “survives_tplus1” “size_tplus1”). printMessages = TRUE (default), messages printed. printMessages = FALSE, messages printed. flagSuspects optional logical argument length 1, indicating whether observations “suspect” flagged. default isflagSuspects = FALSE. flagSuspects = TRUE, column called “Suspect” added output data.frame. suspect observations get “TRUE” “Suspect” column, non-suspect observations receive “FALSE”. two ways observation can classified “suspect”. First, two consecutive observations trackID, observation year t+1 less certain percentage (defined shrink arg.) observation year t, possible observation year t+1 new recruit individual. second way observation can classified “suspect” small going dormant. unlikely small individual survive dormancy, possible function mistakenly given survival value “1” individual. “small individual” observation area certain percentile (specified dormSize) size distribution species, generated using size data species dat. using output dataset demographic analysis, may want exclude “Suspect” observations. flagSuspects = FALSE, additional column added. shrink optional argument takes single numeric value. value used flagSuspects = TRUE. two consecutive observations trackID, ratio size_t+1 size_t smaller value shrink, observation year t gets “TRUE” “Suspect” column. example, shrink = 0.2, individual tracking function identified “BOUGRA_1992_5” area 9 cm2 year_t area 1.35 cm2 year_t+1. ratio size_t+1 size_t 1.35/9 = 0.15, smaller cutoff specified shrink, observation “BOUGRA_1992_5” year t gets “TRUE” “Suspect” column. default value shrink = 0.10. dormSize optional argument takes single numeric value. value used flagSuspects = TRUE dorm ≥ 1. individual flagged “suspect” “goes dormant” size less equal percentile size distribution species designated dormSize. example, dormSize = 0.05, individual basal area 0.5 cm2. 5th percentile distribution size species, made using mean standard deviation observations dat species question, 0.6 cm2. individual overlaps next year (year_t+1), overlap year_t+2. However, basal area observation smaller 5th percentile size species, observation year t get “TRUE” “Suspect” column. possible tracking function mistakenly assigned “1” survival year_t, unlikely individual large enough survive dormancy. default value dormSize = .05. possible arguments trackSpp()!","code":"#>   Species dorm #> 1  tree A    0 #> 2 shrub B    0 #> 3  tree C    0 #> 4  forb D    1 #> 5  forb E    2 #> 6  forb F    1"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"22-function-output","dir":"","previous_headings":"How to use the plantTracker R package > 2 Track individuals through time using trackSpp()","what":"2.2 Function output","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"example potential function call trackSpp(), using example dat inv data ’ve used far. : ’s output call trackSpp() looks like: allow species clonal (clonal = 0) aggByGenet = TRUE call trackSpp(), output data frame one row genet, ready demographic analysis! output data frame yet aggregated genet (.e. use aggByGenet = FALSE), need transform data frame genet represented one row data. can use aggregateByGenet() function plantTracker (see function’s documentation guidance), method choice. can stop proceed analyses using demographic data generated, can proceed plantTracker functions outlined additional useful data.","code":"datTrackSpp <- plantTracker::trackSpp(dat = dat, inv = inv,          dorm = 1,          buff = .05,          buffGenet = .005,          clonal = data.frame(\"Species\" = c(\"Heteropogon contortus\",                                            \"Bouteloua rothrockii\",                                            \"Ambrosia artemisiifolia\",                                            \"Calliandra eriophylla\"),                              \"clonal\" = c(TRUE,TRUE,FALSE,FALSE)),          aggByGenet = TRUE,          printMessages = FALSE          ) #> Simple feature collection with 327 features and 12 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.0002186041 xmax: 1.000536 ymax: 1.000651 #> CRS:           NA #> First 10 features: #>    Site Quad                 Species        trackID Year  type    basalArea #> 1    AZ  SG2 Ambrosia artemisiifolia  AMBART_1922_1 1922 point 2.461883e-05 #> 2    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_10 1922 point 2.461883e-05 #> 3    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_11 1922 point 2.461883e-05 #> 4    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_12 1922 point 2.461883e-05 #> 5    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_13 1922 point 2.461883e-05 #> 6    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_14 1922 point 2.461883e-05 #> 7    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_15 1922 point 2.461883e-05 #> 8    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_16 1922 point 2.461883e-05 #> 9    AZ  SG2 Ambrosia artemisiifolia AMBART_1922_17 1922 point 2.461883e-05 #> 10   AZ  SG2 Ambrosia artemisiifolia AMBART_1922_18 1922 point 2.461883e-05 #>    recruit survives_t+1 age size_t+1 nearEdge                       geometry #> 1       NA            0  NA       NA     TRUE POLYGON ((0.350604 0.021361... #> 2       NA            0  NA       NA    FALSE POLYGON ((0.7172048 0.25834... #> 3       NA            0  NA       NA    FALSE POLYGON ((0.1845598 0.38566... #> 4       NA            0  NA       NA    FALSE POLYGON ((0.759387 0.399850... #> 5       NA            0  NA       NA    FALSE POLYGON ((0.1696044 0.40291... #> 6       NA            0  NA       NA    FALSE POLYGON ((0.7290925 0.41097... #> 7       NA            0  NA       NA    FALSE POLYGON ((0.6255546 0.45737... #> 8       NA            0  NA       NA    FALSE POLYGON ((0.5872073 0.46925... #> 9       NA            0  NA       NA    FALSE POLYGON ((0.8863168 0.52256... #> 10      NA            0  NA       NA    FALSE POLYGON ((0.5212498 0.52831..."},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"3-calculate-local-neighborhood-density-using-getneighbors","dir":"","previous_headings":"How to use the plantTracker R package","what":"3 Calculate local neighborhood density using getNeighbors()","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"often useful demographic analyses idea competition (facilitation) individual organism dealing . Interactions individuals can profound impact whether organism survives grows. Spatial datasets plant occurrence allow us generate estimate interactions individual plant plants determining many individuals occupy “local neighborhood” focal plant. isn’t direct measure competition facilitation, gives us estimate can include demographic models. generic getNeighbors() function:","code":"getNeighbors(dat, buff, method, compType = \"allSpp\", output = \"summed\",   trackID = \"trackID\", species = \"Species\", quad = \"Quad\", year = \"Year\",   site = \"Site\", geometry = \"geometry\", ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"31-function-options-and-arguments","dir":"","previous_headings":"How to use the plantTracker R package > 3 Calculate local neighborhood density using getNeighbors()","what":"3.1 Function options and arguments","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"getNeighbors() function plantTracker calculates local neighborhood density unique individual dataset. user-specified buffer drawn around individual, function counts number plants within buffer.function can run dataset unique individual (genet) represented one row data. genet consists multiple polygons, must aggregated one sf MULTIPOLYGON object. dataset multiple rows genet, can use aggregateByGenet() function get ready use getNeighbors(). Additionally, getNeighbors() requires dataset column containing unique identifier genet. Across multiple years, genet must unique identifier. using function right trackSpp(), dataset already unique identifier column called “trackID”. getNeighbors() several options allow customize local neighborhood density calculated. First, user can decide function “counts” plants inside buffer zone around focal individual. Option 1) function tally number genets inside buffer zone. Option 2) function calculate proportion buffer zone occupied plants. Second, user can decide whether function calculate intraspecific local neighborhood density (consider plants buffer zone species focal individual) interspecific local neighborhood density (consider plants buffer zone, regardless species). Third, user can decide whether neighborhood density value (either count area) focal individual single value sums number area neighbors, whether actually list provides neighborhood density species present neighborhood. Figure 3.1: individual outlined pink focal individual, pale pink shows 10 cm buffer around . Figure 3.2: 10cm buffer around focal individual overlaps 5 unique individuals two species. overlapping individuals outlined dark grey. Using ‘count’ method getNeighbors(), get intraspecific competition value 3, interspecific competition value 5. Figure 3.3: 10cm buffer around focal individual overlaps 5 unique individuals two species. overlapping area shaded grey. Using ‘area’ method getNeighbors(), get intraspecific competition metric 0.0454, interspecific competition metric 0.0462. arguments getNeighbors() function. dat sf data frame row represents data unique individual organism unique year. sf geometry row must either MULTIPOLYGON POLYGON geometry. addition “geometry” column, data frame must columns contain data indicating site, quadrat, site, year observation. also must column contains unique identifying value genet year. dat coming directly trackSpp(), column called “trackID”. buff single numeric value indicates desired width “buffer” around focal individual competitors counted. value must units spatial information dat. method character string must equal either \"count\" \"area\". method = \"count\", number individuals buffer area tallied. method = \"area\", proportion buffer area occupied individuals calculated. compType character string must either \"allSpp\" \"oneSpp\". compType = \"allSpp\", metric interspecific competition calculated, meaning every individual within buffer around focal individual considered, matter species. compType = \"oneSpp\", metric intraspecific competition calculated, meaning individuals species focal individual considered calculating competition metric. value provided, default “allSpp”. output character string set either \"summed\" \"bySpecies\". default \"summed\". argument important consider using compType = \"allSpp\". output = \"summed\", one count/area value returned individual. value total count area neighbors within focal species buffer zone, regardless species. output = \"bySpecies\", count area value returned species present buffer zone. example, using getNeighbors() method = \"count\" compType = \"allSpp\". focal individual dataset seven plants inside buffer zone, three species , two species B, 2 species C. output = \"summed\", value “neighbors_count” column returned data frame simply contain value “7”. output = \"bySpecies\", “neighbors_count” column individual actually contain named list {r} list(\"Species \"= 5, \"Species B\" = 3, \"Species C\" = 7). default value output \"summed\". trackID/species/quad/year/site/geometry arguments need included columns dat contain data trackID, species, site, quadrat, year geometry observation different names “trackID,”Species“,”Site“,”Quad“,”Year, “geometry”. example, column version dat contains species identity observation called “species_names”, argument species = \"species_names\" must included call getNeighbors().","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"32-function-outputs","dir":"","previous_headings":"How to use the plantTracker R package > 3 Calculate local neighborhood density using getNeighbors()","what":"3.2 Function outputs","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"output getNeighbors() sf data frame identical input dat, either one two additional columns. method = \"area\", two columns added called “nBuff_area” “neighbors_area”. first contains area buffer zone around focal individual. second contains basal area neighbors overlap focal individual’s buffer zone. method = \"count\", one additional column added output, called “neighbors_count.” column contains count neighbors occur within focal individual’s buffer zone. ’s example getNeighbors() function call using resulting data example section 2.2, well resulting data frame. Note method = \"area\", two columns added returned data frame: example uses option output = \"summed\", default getNeighbors() function. option, “neighbors_area” “neighbors_count” column (depending method argument) contains just one value sums neighbor count area across neighbor species. However, output = \"bySpecies\", “neighbors_count” “neighbors_area” column contains list counts areas broken species. output argument described detail section 3.1. want use getNeighbors() function determine effect neighbors differs according species identity neighbors, setting output = \"bySpecies\" allows . However, likely subsequent analyses need -species neighbor data matrix data frame format, rather list nested inside data frame, getNeighbors() returns data. code turns data returned getNeighbors(output = \"bySpecies\") matrix row data one focal individual, column data one species. format easier work analysis.","code":"datNeighbors <- plantTracker::getNeighbors(dat = datTrackSpp,              buff = .15,              method = \"area\",              compType = \"allSpp\") #> Simple feature collection with 327 features and 14 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.0002186041 xmax: 1.000536 ymax: 1.000651 #> CRS:           NA #> First 10 features: #>                    Species Site Quad        trackID Year neighbors_area #> 1  Ambrosia artemisiifolia   AZ  SG2  AMBART_1922_1 1922   0.0011328591 #> 2  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_10 1922   0.0040518140 #> 3  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_11 1922   0.0055774468 #> 4  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_12 1922   0.0029129080 #> 5  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_13 1922   0.0050297901 #> 6  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_14 1922   0.0037646754 #> 7  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_15 1922   0.0026270846 #> 8  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_16 1922   0.0013297048 #> 9  Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_17 1922   0.0022690175 #> 10 Ambrosia artemisiifolia   AZ  SG2 AMBART_1922_18 1922   0.0006338116 #>    nBuff_area basalArea basalArea_genet survives_t+1 survives_tplus1 size_t+1 #> 1  0.04320540     point    2.461883e-05           NA               0       NA #> 2  0.07329218     point    2.461883e-05           NA               0       NA #> 3  0.07329218     point    2.461883e-05           NA               0       NA #> 4  0.07329218     point    2.461883e-05           NA               0       NA #> 5  0.07329218     point    2.461883e-05           NA               0       NA #> 6  0.07329218     point    2.461883e-05           NA               0       NA #> 7  0.07329218     point    2.461883e-05           NA               0       NA #> 8  0.07329218     point    2.461883e-05           NA               0       NA #> 9  0.06848976     point    2.461883e-05           NA               0       NA #> 10 0.07329218     point    2.461883e-05           NA               0       NA #>    size_tplus1 nearEdge                       geometry #> 1           NA     TRUE POLYGON ((0.350604 0.021361... #> 2           NA    FALSE POLYGON ((0.7172048 0.25834... #> 3           NA    FALSE POLYGON ((0.1845598 0.38566... #> 4           NA    FALSE POLYGON ((0.759387 0.399850... #> 5           NA    FALSE POLYGON ((0.1696044 0.40291... #> 6           NA    FALSE POLYGON ((0.7290925 0.41097... #> 7           NA    FALSE POLYGON ((0.6255546 0.45737... #> 8           NA    FALSE POLYGON ((0.5872073 0.46925... #> 9           NA    FALSE POLYGON ((0.8863168 0.52256... #> 10          NA    FALSE POLYGON ((0.5212498 0.52831... # save the output of the getNeighbors() function datNeighbors_bySpp <- plantTracker::getNeighbors(dat = datTrackSpp,              buff = .15, method = \"area\", compType = \"allSpp\", output = \"bySpecies\")  # determine all of the possible species that can occupy the buffer zone compSpp <- unique(datTrackSpp$Species)  temp <- lapply(X = datNeighbors_bySpp$neighbors_area,  FUN = function(x) {   tmp <- unlist(x)   tmp2 <- tmp[compSpp]   } )  for (i in 1:length(temp)) {   # fix the column names   names(temp[[i]]) <- compSpp   # save the data in a matrix   if (i == 1) {     datOut <- temp[[i]]   } else {     datOut <- rbind(datOut, temp[[i]])   } } # make the rownames of the matrix correspond to the trackID of the focal individual rownames(datOut) <- datNeighbors_bySpp$trackID  # show the first few rows of the datOut data frame:  datOut[1:5,] #>                Ambrosia artemisiifolia Bouteloua rothrockii #> AMBART_1922_1             4.923767e-05         5.216672e-04 #> AMBART_1922_10            8.437672e-05         1.250163e-03 #> AMBART_1922_11            2.461883e-05         2.310445e-04 #> AMBART_1922_12            9.353468e-05         7.408342e-04 #> AMBART_1922_13            2.461883e-05         1.906272e-08 #>                Calliandra eriophylla Heteropogon contortus #> AMBART_1922_1                     NA          0.0005619542 #> AMBART_1922_10                    NA          0.0027172740 #> AMBART_1922_11                    NA          0.0053217835 #> AMBART_1922_12                    NA          0.0020785392 #> AMBART_1922_13                    NA          0.0050051522"},{"path":"http://www.astearsresearch.com/package/plantTracker/index.html","id":"4-next-steps","dir":"","previous_headings":"How to use the plantTracker R package","what":"4 Next steps","title":"Extract Demographic and Competition Data from Fine-scale Maps","text":"point, dataset ready use applications wish! additional functions may help analyses, outlined section. Calculate recruitment species--plot--year: getRecruits() function Calculate population rate increase (lambda) species plot: getLambda() function Calculate basal area species quadrat year: getBasalAreas() function Make maps quadrats time: drawQuadMap() function Specific instructions use functions can found documentation!","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":null,"dir":"Reference","previous_headings":"","what":"aggregateByGenet — aggregateByGenet","title":"aggregateByGenet — aggregateByGenet","text":"function aggregates data.frame unique trackIDs row represents genet (unique genetic individual) given year.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"aggregateByGenet — aggregateByGenet","text":"","code":"aggregateByGenet(   dat,   site = \"Site\",   quad = \"Quad\",   species = \"Species\",   year = \"Year\",   trackID = \"trackID\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"aggregateByGenet — aggregateByGenet","text":"dat sf data.frame. Typically data.frame returned trackSpp() function, although 'dat' can sf data.frame plant demographic data genet given unique identifying value (call 'trackID'). 'dat' already one row unique trackID unique year (.e. vegetative individuals--ramets), output aggregateByGenet() number rows 'dat'. 'dat' multiple rows (ramet) trackID year, output aggregateByGenet() fewer rows input 'dat' data.frame. 'dat' MUST columns called 'basalArea_genet', 'age', 'recruit', 'survives_tplus1', 'nearEdge', 'size_tplus1', although can populated NAs. trackSpp() function adds columns, made changes data.frame returned trackSpp(), data.frame columns already. site character string giving name column 'dat' contains values site. default \"Site\". quad character string giving name column 'dat' contains values quadrat. default \"Quad\". species character string giving name column 'dat' contains values species. default \"Species\". year character string giving name column 'dat' contains values year. default \"Year\". trackID character string giving name column 'dat' contains values unique identifier, trackID. default \"trackID\". ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"aggregateByGenet — aggregateByGenet","text":"sf data.frame aggregated genet row represents one unique genetic individual one year. data.frame columns containing data site, quadrat, species, year, trackID, well columns called 'basalArea_genet', 'age', 'recruit', 'survives_tplus1', 'nearEdge', 'size_tplus1'. data.frame likely shorter input 'dat', genet previously broken multiple rows representing ramet year now one row year.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"aggregateByGenet — aggregateByGenet","text":"function plantTracker-specific, user-friendly wrapper 'aggregate' function. function designed use within trackSpp function, can also called independently user. function designed take data.frame format returned trackSpp(), can used aggregate dataset genet (unique identifier), long column identifies genet (unique identifier) identity observation.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/aggregateByGenet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"aggregateByGenet — aggregateByGenet","text":"","code":"dat <- grasslandData[grasslandData$Site == c(\"AZ\") &  grasslandData$Species %in% c(\"Bouteloua rothrockii\", \"Calliandra eriophylla\" ),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = FALSE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\"  aggregateByGenet(dat = outDat, species = 'speciesName') #> Simple feature collection with 346 features and 11 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.001017592 xmax: 1.000536 ymax: 1.001267 #> CRS:           NA #> First 10 features: #>    Site Quad          speciesName        trackID Year basalArea_genet recruit #> 1    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_1 1922    9.636323e-04      NA #> 2    AZ  SG2 Bouteloua rothrockii BOUROT_1922_10 1922    1.250163e-03      NA #> 3    AZ  SG2 Bouteloua rothrockii BOUROT_1922_11 1922    2.504885e-05      NA #> 4    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_2 1922    1.765691e-03      NA #> 5    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_3 1922    8.045954e-04      NA #> 6    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_3 1924    5.705242e-04      NA #> 7    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_3 1925    2.482590e-04      NA #> 8    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_3 1926    8.397793e-04      NA #> 9    AZ  SG2 Bouteloua rothrockii  BOUROT_1922_3 1927    1.427247e-03      NA #> 10   AZ  SG2 Bouteloua rothrockii  BOUROT_1922_4 1922    7.043062e-04      NA #>    survives_tplus1 age  size_tplus1 nearEdge                       geometry #> 1                0  NA           NA     TRUE POLYGON ((0.9556098 0.07696... #> 2                0  NA           NA    FALSE POLYGON ((0.6691549 0.24262... #> 3                0  NA           NA    FALSE POLYGON ((0.6470947 0.51129... #> 4                0  NA           NA     TRUE POLYGON ((0.9843703 0.37799... #> 5                1  NA 0.0005705242     TRUE POLYGON ((0.8766142 0.95972... #> 6                1  NA 0.0002482590     TRUE POLYGON ((0.8232826 0.97669... #> 7                1  NA 0.0008397793     TRUE POLYGON ((0.8734301 0.94362... #> 8                1  NA 0.0014272470     TRUE POLYGON ((0.8896559 0.93777... #> 9               NA  NA           NA     TRUE MULTIPOLYGON (((0.8745275 0... #> 10               0  NA           NA    FALSE POLYGON ((0.1223214 0.70317..."},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Tracks genets through time — assign","title":"Tracks genets through time — assign","text":"function tracks individual plants time, one species one quadrat. designed use within trackSpp function, intended use .","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tracks genets through time — assign","text":"","code":"assign(   dat,   inv,   dorm,   buff,   buffGenet,   clonal,   flagSuspects = FALSE,   shrink = 0.1,   dormSize = 0.05,   inheritsFromTrackSpp = FALSE,   nearEdgeBox = NULL,   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tracks genets through time — assign","text":"dat sf data.frame format grasslandData. 'dat' must contain data one species one quadrat. must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\") s.f 'geometry' column contains polygon multipolygon data type individual observation. function add columns called \"basalArea_ramet\", \"trackID\", \"age\", \"size_tplus1\", \"recruit\" \"survives_tplus1\", 'dat' contain columns names. inv integer vector contains years quadrat (unique spatial area) sampled. Years must ordered sequentially. dorm numeric vector length 1, indicating number years species allowed go dormant, .e. absent map considered individual reappears. must integer greater equal 0. buff numeric vector length 1 greater equal zero, indicating far (units spatial values 'dat') polygon can move year t year t+1 still considered individual. buffGenet numeric vector length 1 greater equal zero, indicating close (units spatial values 'dat') polygons must one another year grouped genet ('clonal' argument = TRUE). argument passed groupByGenet function, used inside assign function. clonal logical argument length 1, indicating whether species allowed clonal (.e. multiple polygons (ramets) can grouped one individual (genet)). clonal = TRUE, species allowed clonal, clonal = FALSE, species allowed clonal. flagSuspects logical argument length 1, indicating whether observations 'suspect' flagged. default flagSuspects = FALSE. flagSuspects = TRUE, column called 'Suspect' added output data.frame. suspect observations get 'TRUE' 'Suspect' column, non-suspect observations receive 'FALSE'. two ways observation can classified 'suspect'. First, two consecutive observations trackID, basal area observation year t+1 less certain percentage (defined shrink arg.) basal area observation year t, possible observation year t+1 new recruit individual. second way observation can classified 'suspect' small going dormant. unlikely small individual survive dormancy, possible function mistakenly given survival value '1' individual. 'small individual' observation area certain percentile (specified 'dormSize') size distribution species, generated using size data species 'dat'. shrink single numeric value. value used flagSuspects = TRUE. two consecutive observations trackID, ratio size_t+1 size_t smaller value shrink, observation year t gets 'TRUE' 'Suspect' column. example, shrink = 0.2, individual tracking function identified 'BOUGRA_1992_5' area 9 cm^2 year t area 1.35 cm^2 year t+1. ratio size t+1 size t 1.35/9 = 0.15, smaller cutoff specified shrink, observation BOUGRA_1992_5' year t gets 'TRUE' 'Suspect' column. default value shrink = 0.10. dormSize single numeric value. value used flagSuspects = TRUE dorm ≥ 1. individual flagged 'suspect' 'goes dormant' size less equal percentile size distribution species designated dormSize. example, dormSize = 0.05, focal individual basal area 0.5 cm^2. 5th percentile distribution size species, made using mean standard deviation observations 'dat' species question, 0.6 cm^2. individual overlaps next year (year t+1), overlap year t+2. However, basal area observation smaller 5th percentile size species, observation year t get 'TRUE' 'Suspect' column. possible tracking function mistakenly assigned '1' survival year t, unlikely individual large enough survive dormancy. default value dormSize = .05. inheritsFromTrackSpp logical argument applicable 'assign()' used internally 'trackSpp()'. nearEdgeBox sf data frame indicating bounding box quadrat. argument used 'assign()' used internally 'trackSpp()'. ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/assign.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tracks genets through time — assign","text":"see trackSpp details arguments usage.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":null,"dir":"Reference","previous_headings":"","what":"checkDat — checkDat","title":"checkDat — checkDat","text":"function checks prepares data.frame use trackSpp function.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checkDat — checkDat","text":"","code":"checkDat(   dat,   inv = NULL,   species = \"Species\",   site = \"Site\",   quad = \"Quad\",   year = \"Year\",   geometry = \"geometry\",   reformatDat = FALSE,   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checkDat — checkDat","text":"dat sf data.frame format grasslandData. must columns contains unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\") s.f 'geometry' column contains polygon multipolygon data type individual observation. inv name element list quadrat name 'dat', contents list element numeric vector years quadrat (unique spatial area) sampled. Make sure years quadrat actually sampled, just years data 'dat' argument! argument allows function differentiate years quadrat sampled years just individuals species present quadrat. species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary include value argument column name \"geometry\" (default 'geometry'). reformatDat TRUE/FALSE argument. 'FALSE', default value, checkDat() prints message says 'dat' 'inv' datasets ready use trackSpp() function. message includes column name arguments must included trackSpp() function call datasets. 'TRUE', checkDat() returns list three elements: version 'dat' checked errors ready input directly  trackSpp  assign functions, version 'inv' checked ready input trackSpp() assign(), character vector called 'userColNames' user-defined column names used original version 'dat'. ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"checkDat — checkDat","text":"'reformatDat' argument FALSE (default), return function message says 'dat' 'inv' datasets ready use trackSpp() function. message includes column name arguments must included trackSpp() function call datasets. 'reformatDat' argument TRUE, checkDat() returns list contains versions 'dat' 'inv' ready go directly trackSpp() assign() functions. list following elements: dat sf data.frame five columns called 'Species', 'Site', 'Quad', 'Year', 'geometry'. additional columns present version 'dat' input checkDat() function also included version, although column names appended \"_USER\". inv named list. name element list quadrat name 'dat', contents list element numeric vector years quadrat (unique spatial area) sampled. list element, vector years sequential order oldest recent. userColNames named character vector. vector contains column names provided user required data columns original version 'dat'. name vector element indicates type data contained column name vector element. example, 'dat' data.frame input checkDat() names 'Species','location' 'quadrat', 'Year', 'geometry', list element character vector values names 'species', 'site', 'quad', 'year', 'geometry'.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"checkDat — checkDat","text":"function used internally trackSpp plantTracker functions check 'dat' 'inv' arguments ensure correct format correct column names. checkDat() can also used independently check data.frame correct format contains correct data used trackSpp() plantTracker functions.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/checkDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"checkDat — checkDat","text":"","code":"checkDat(dat = grasslandData, inv = grasslandInventory) #> The data you put into the 'checkDat()' function for the 'dat' and #>         'inv' arguments are ready to be used in the 'trackSpp()' function! You #>         do not need to include any values for the 'species', 'site', 'quad', #>         'year', and 'geometry' arguments in 'trackSpp()  checkDat(dat = grasslandData, inv = grasslandInventory, reformatDat = TRUE) #> $dat #> Simple feature collection with 1242 features and 12 fields #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: -0.001386579 ymin: -0.001470638 xmax: 1.000536 ymax: 1.001267 #> CRS:           NA #> First 10 features: #>                      Species Clone_USER Seedling_USER Stems_USER Basal_USER #> 117603 Heteropogon contortus          0             0         NA         NA #> 117604 Heteropogon contortus          0             0         NA         NA #> 117605 Heteropogon contortus          0             0         NA         NA #> 117606 Heteropogon contortus          0             0         NA         NA #> 117607 Heteropogon contortus          0             0         NA         NA #> 117608 Heteropogon contortus          0             0         NA         NA #> 117609 Heteropogon contortus          0             0         NA         NA #> 117610 Heteropogon contortus          0             0         NA         NA #> 117611 Heteropogon contortus          0             0         NA         NA #> 117612 Heteropogon contortus          0             0         NA         NA #>        Type_USER Site Quad Year sp_code_4_USER sp_code_6_USER    Area_USER #> 117603      poly   AZ  SG2 1922           HECO         HETCON 0.0006140896 #> 117604      poly   AZ  SG2 1922           HECO         HETCON 0.0014183352 #> 117605      poly   AZ  SG2 1922           HECO         HETCON 0.0005743856 #> 117606      poly   AZ  SG2 1922           HECO         HETCON 0.0009549092 #> 117607      poly   AZ  SG2 1922           HECO         HETCON 0.0016950661 #> 117608      poly   AZ  SG2 1922           HECO         HETCON 0.0037240299 #> 117609      poly   AZ  SG2 1922           HECO         HETCON 0.0012574011 #> 117610      poly   AZ  SG2 1922           HECO         HETCON 0.0019521166 #> 117611      poly   AZ  SG2 1922           HECO         HETCON 0.0011659233 #> 117612      poly   AZ  SG2 1922           HECO         HETCON 0.0009111819 #>                              geometry #> 117603 POLYGON ((0.237747 0.908835... #> 117604 POLYGON ((0.2833037 0.85959... #> 117605 POLYGON ((0.008583123 0.449... #> 117606 POLYGON ((0.1480142 0.46983... #> 117607 POLYGON ((0.03573306 0.5259... #> 117608 POLYGON ((0.2441894 0.52689... #> 117609 POLYGON ((0.2888257 0.51815... #> 117610 POLYGON ((0.3527891 0.45648... #> 117611 POLYGON ((0.6749071 0.82646... #> 117612 POLYGON ((0.4604686 0.76526... #>  #> $inv #> $inv$C5 #> [1] 1936 1937 1938 1939 1940 #>  #> $inv$D1 #> [1] 1936 1937 1938 1939 1940 #>  #> $inv$SG2 #> [1] 1922 1923 1924 1925 1926 1927 #>  #> $inv$SG4 #> [1] 1922 1923 1924 1925 1926 1927 #>  #>  #> $userColNames #>    species       site       quad       year   geometry  #>  \"Species\"     \"Site\"     \"Quad\"     \"Year\" \"geometry\"  #>"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/drawQuadMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create maps of a quadrat over time — drawQuadMap","title":"Create maps of a quadrat over time — drawQuadMap","text":"function creates maps quadrat time, color-coded either species genet (trackID).","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/drawQuadMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create maps of a quadrat over time — drawQuadMap","text":"","code":"drawQuadMap(   dat,   type = \"bySpecies\",   addBuffer = FALSE,   species = \"Species\",   site = \"Site\",   quad = \"Quad\",   year = \"Year\",   geometry = \"geometry\",   trackID = \"trackID\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/drawQuadMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create maps of a quadrat over time — drawQuadMap","text":"dat sf data.frame row represents unique polygon (either genet ramet) unique site/quadrat/year combination. recommended input data one quadrat time. data.frame returned trackSpp can put function subset quadrat. 'dat' must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\"), unique identifier genet (default name 'trackID') s.f 'geometry' column contains polygon multipolygon data type individual observation. type character argument indicating plots returned drawQuadMap() color coded. type = \"bySpecies\", observations color-coded species. type = \"bytrackID\", observations color-coded trackID. default value \"bySpecies\". addBuffer logical argument indicating whether drawQuadMap() draw small buffer around polygon returned maps make observations visible. particularly useful observations originally mapped points, hard see plotted original dimensions. buffer distance 1/20th quadrat width. default value FALSE. species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary include value argument column name \"geometry\" (default 'geometry'). trackID optional character string argument. Indicates name column 'dat' contains unique identifiers genet. unnecessary include value argument column name \"trackID\" (default 'trackID') ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/drawQuadMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create maps of a quadrat over time — drawQuadMap","text":"function returns multipanel plot panel shows map quadrat unique year. Panels arranged chronological order, plots color-coded either species trackID (unique genet identifier). #' @seealso trackSpp(), can used assign trackIDs observations.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/drawQuadMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create maps of a quadrat over time — drawQuadMap","text":"","code":"dat <- grasslandData[grasslandData$Site == c(\"AZ\") &  grasslandData$Quad == \"SG2\" &  grasslandData$Year %in% c(1922:1925),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Heteropogon contortus; Bouteloua rothrockii; Ambrosia artemisiifolia; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\" drawQuadMap(dat = outDat, type = \"bySpecies\", addBuffer = FALSE, species = \"speciesName\" )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getBasalAreas.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates basal area for each species in a quadrat — getBasalAreas","title":"Calculates basal area for each species in a quadrat — getBasalAreas","text":"function calculates total basal area species present quadrat year data collection. absolute basal area (units area input data.frame) returned, well percentage total occupied basal area quadrat occupied given species (\"percent total basal area\"). like ultimately calculate population growth rate (lambda) species, can use getLambda function directly, takes raw species occurrence data (like 'dat' ) returns lambda values species quadrat transition dataset. function used individuals 'dat' mapped polygons representative actual basal area, .e. mapped points.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getBasalAreas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates basal area for each species in a quadrat — getBasalAreas","text":"","code":"getBasalAreas(   dat,   inv,   species = \"Species\",   quad = \"Quad\",   site = \"Site\",   year = \"Year\",   geometry = \"geometry\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getBasalAreas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates basal area for each species in a quadrat — getBasalAreas","text":"dat sf data.frame row represents unique polygon (either genet ramet) unique site/quadrat/year combination. data.frame returned trackSpp can put directly function. However, necessary 'dat' demographic data unique identifiers (.e. 'trackIDs') assigned. 'dat' must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\"), s.f 'geometry' column contains polygon multipolygon data type individual observation. function used individuals 'dat' mapped polygons representative actual basal area, .e. mapped points. inv name element list quadrat name 'dat', contents list element numeric vector years quadrat (unique spatial area) sampled. Make sure years quadrat actually sampled, just years data 'dat' argument! argument allows function differentiate years quadrat sampled years just individuals species present quadrat. species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary include value argument column name \"geometry\" (default 'geometry'). ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getBasalAreas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates basal area for each species in a quadrat — getBasalAreas","text":"getBasalAreas() returns data.frame columns \"Site\", \"Quad\", \"Year\" \"Species\". two rows values four columns. column \"absolute_basalArea\" area quadrat occupied species given unique site/quadrat/year combination. units area 'dat'. \"quad_basalArea\" gives combined basal area plants given site/quadrat/year. \"percent_basalArea\" gives percentage occupied basal area within quadrat occupied species given site/quadrat/year. example, species basal area 22 cm^2 quadrat 1 2005 (\"absolute_basalArea = 22). 2005, 50 cm^2 quadrat 1 occupied plants (\"quad_basalArea\" = 55). 44% occupied basal area quadrat 1 2005 occupied species (\"percent_basalArea\" = 44). may 'NA' \"percent_basalArea\" column \"quad_basalArea\" species year 0.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getBasalAreas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates basal area for each species in a quadrat — getBasalAreas","text":"","code":"dat <- grasslandData[grasslandData$Site == \"AZ\" &  grasslandData$Year %in% c(1922:1925),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Heteropogon contortus; Bouteloua rothrockii; Ambrosia artemisiifolia; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Ambrosia artemisiifolia; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\" getBasalAreas(dat = outDat, inv = inv, species = \"speciesName\") #>    Site Quad Year             speciesName absolute_basalArea quad_basalArea #> 1    AZ  SG2 1922 Ambrosia artemisiifolia       8.862780e-04    0.036796013 #> 2    AZ  SG2 1922   Heteropogon contortus       2.820466e-02    0.036796013 #> 3    AZ  SG2 1922    Bouteloua rothrockii       7.655839e-03    0.036796013 #> 4    AZ  SG2 1922   Calliandra eriophylla       4.923767e-05    0.036796013 #> 5    AZ  SG2 1923    Bouteloua rothrockii       4.225758e-03    0.034943462 #> 6    AZ  SG2 1923 Ambrosia artemisiifolia       0.000000e+00    0.034943462 #> 7    AZ  SG2 1923   Heteropogon contortus       3.071770e-02    0.034943462 #> 8    AZ  SG2 1923   Calliandra eriophylla       0.000000e+00    0.034943462 #> 9    AZ  SG2 1924 Ambrosia artemisiifolia       0.000000e+00    0.034182001 #> 10   AZ  SG2 1924    Bouteloua rothrockii       4.278202e-03    0.034182001 #> 11   AZ  SG2 1924   Calliandra eriophylla       4.923767e-05    0.034182001 #> 12   AZ  SG2 1924   Heteropogon contortus       2.985456e-02    0.034182001 #> 13   AZ  SG2 1925 Ambrosia artemisiifolia       0.000000e+00    0.014798927 #> 14   AZ  SG2 1925    Bouteloua rothrockii       7.640600e-03    0.014798927 #> 15   AZ  SG2 1925   Calliandra eriophylla       7.385650e-05    0.014798927 #> 16   AZ  SG2 1925   Heteropogon contortus       7.084470e-03    0.014798927 #> 17   AZ  SG2 1926    Bouteloua rothrockii       0.000000e+00    0.000000000 #> 18   AZ  SG2 1926 Ambrosia artemisiifolia       0.000000e+00    0.000000000 #> 19   AZ  SG2 1926   Heteropogon contortus       0.000000e+00    0.000000000 #> 20   AZ  SG2 1926   Calliandra eriophylla       0.000000e+00    0.000000000 #> 21   AZ  SG2 1927    Bouteloua rothrockii       0.000000e+00    0.000000000 #> 22   AZ  SG2 1927   Calliandra eriophylla       0.000000e+00    0.000000000 #> 23   AZ  SG2 1927 Ambrosia artemisiifolia       0.000000e+00    0.000000000 #> 24   AZ  SG2 1927   Heteropogon contortus       0.000000e+00    0.000000000 #> 25   AZ  SG4 1922 Ambrosia artemisiifolia       2.461883e-04    0.002926715 #> 26   AZ  SG4 1922    Bouteloua rothrockii       2.680527e-03    0.002926715 #> 27   AZ  SG4 1922   Calliandra eriophylla       0.000000e+00    0.002926715 #> 28   AZ  SG4 1923 Ambrosia artemisiifolia       0.000000e+00    0.002782187 #> 29   AZ  SG4 1923    Bouteloua rothrockii       2.782187e-03    0.002782187 #> 30   AZ  SG4 1923   Calliandra eriophylla       0.000000e+00    0.002782187 #> 31   AZ  SG4 1924 Ambrosia artemisiifolia       0.000000e+00    0.002478312 #> 32   AZ  SG4 1924    Bouteloua rothrockii       2.404456e-03    0.002478312 #> 33   AZ  SG4 1924   Calliandra eriophylla       7.385650e-05    0.002478312 #> 34   AZ  SG4 1925 Ambrosia artemisiifolia       0.000000e+00    0.002199422 #> 35   AZ  SG4 1925    Bouteloua rothrockii       2.199422e-03    0.002199422 #> 36   AZ  SG4 1925   Calliandra eriophylla       0.000000e+00    0.002199422 #> 37   AZ  SG4 1926 Ambrosia artemisiifolia       0.000000e+00    0.000000000 #> 38   AZ  SG4 1926    Bouteloua rothrockii       0.000000e+00    0.000000000 #> 39   AZ  SG4 1926   Calliandra eriophylla       0.000000e+00    0.000000000 #> 40   AZ  SG4 1927 Ambrosia artemisiifolia       0.000000e+00    0.000000000 #> 41   AZ  SG4 1927    Bouteloua rothrockii       0.000000e+00    0.000000000 #> 42   AZ  SG4 1927   Calliandra eriophylla       0.000000e+00    0.000000000 #>    percent_basalArea #> 1          2.4086251 #> 2         76.6513976 #> 3         20.8061648 #> 4          0.1338125 #> 5         12.0931293 #> 6          0.0000000 #> 7         87.9068707 #> 8          0.0000000 #> 9          0.0000000 #> 10        12.5159496 #> 11         0.1440456 #> 12        87.3400048 #> 13         0.0000000 #> 14        51.6294202 #> 15         0.4990666 #> 16        47.8715132 #> 17                NA #> 18                NA #> 19                NA #> 20                NA #> 21                NA #> 22                NA #> 23                NA #> 24                NA #> 25         8.4117628 #> 26        91.5882372 #> 27         0.0000000 #> 28         0.0000000 #> 29       100.0000000 #> 30         0.0000000 #> 31         0.0000000 #> 32        97.0198869 #> 33         2.9801131 #> 34         0.0000000 #> 35       100.0000000 #> 36         0.0000000 #> 37                NA #> 38                NA #> 39                NA #> 40                NA #> 41                NA #> 42                NA"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getLambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","title":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","text":"function calculates population growth rate (lambda) every species quadrat. value ratio basal area number individuals next year basal area number individuals current year (basal area year t+1/ basal area year t). lambda value greater 1 indicates population growing, value less 1 indicates population decline. Lambda 'infinity' basal area number individuals year t 0, NA basal area number individuals year t zero (.e. plants present year t). Note lambda value calculated years quadrat sampled, even gap sampling. example, quadrat sampled 1998, 1999, 2001, 2002 (skipped 2000). lambda value calculated 1998-1999 2001-2002, transition year t year t+1. However, lambda value calculated manner 1999-2001, actually transition year t year t+2. can remove values subsetting data.frame returned getLambda() rows \"Year_tplus1\"- \"Year_t\" equal 1.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getLambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","text":"","code":"getLambda(   dat,   inv,   method = \"area\",   species = \"Species\",   quad = \"Quad\",   site = \"Site\",   year = \"Year\",   geometry = \"geometry\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getLambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","text":"dat sf data.frame row represents unique polygon (either genet ramet) unique site/quadrat/year combination. data.frame returned trackSpp can put directly function. However, necessary 'dat' demographic data unique identifiers (.e. 'trackIDs') assigned. 'dat' must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\"), s.f 'geometry' column contains polygon multipolygon data type individual observation. inv name element list quadrat name 'dat', contents list element numeric vector years quadrat (unique spatial area) sampled. Make sure years quadrat actually sampled, just years data 'dat' argument! argument allows function differentiate years quadrat sampled years just individuals species present quadrat. method single character argument determines method calculating lambda. default value \"area\", means lambda calculated comparing total basal area given species year t+1 year t. 'method' = \"count\", lambda calculated comparing total number individuals given species year t+1 year t. individual 'dat' mapped point, best use 'method' = \"count\". species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary include value argument column name \"geometry\" (default 'geometry'). ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getLambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","text":"function returns data.frame columns containing site, quadrat, species data, well following columns: Year_t 'current' year absolute_basalArea_t basal area (units spatial elements 'dat') species quadrat year 't' Year_tplus1 'next' year absolute_basalArea_tplus1 basal area (units spatial elements 'dat') species quadrat year 't+1' lambda population growth rate species quadrat year t year t+1.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getLambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates lambda, the population growth rate, for each species in a quadrat\nbased on changes in basal cover. — getLambda","text":"","code":"dat <- grasslandData[grasslandData$Site == \"AZ\" &  grasslandData$Year %in% c(1922:1925),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Heteropogon contortus; Bouteloua rothrockii; Ambrosia artemisiifolia; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Ambrosia artemisiifolia; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\" getLambda(dat = outDat, inv = inv, method = \"area\", species = \"speciesName\") #>    Site Quad             speciesName Year_t absolute_basalArea_t Year_tplus1 #> 1    AZ  SG2 Ambrosia artemisiifolia   1922         8.862780e-04        1923 #> 2    AZ  SG2 Ambrosia artemisiifolia   1923         0.000000e+00        1924 #> 3    AZ  SG2 Ambrosia artemisiifolia   1924         0.000000e+00        1925 #> 4    AZ  SG2 Ambrosia artemisiifolia   1925         0.000000e+00        1926 #> 5    AZ  SG2 Ambrosia artemisiifolia   1926         0.000000e+00        1927 #> 6    AZ  SG2   Heteropogon contortus   1922         2.820466e-02        1923 #> 7    AZ  SG2   Heteropogon contortus   1923         3.071770e-02        1924 #> 8    AZ  SG2   Heteropogon contortus   1924         2.985456e-02        1925 #> 9    AZ  SG2   Heteropogon contortus   1925         7.084470e-03        1926 #> 10   AZ  SG2   Heteropogon contortus   1926         0.000000e+00        1927 #> 11   AZ  SG2    Bouteloua rothrockii   1922         7.655839e-03        1923 #> 12   AZ  SG2    Bouteloua rothrockii   1923         4.225758e-03        1924 #> 13   AZ  SG2    Bouteloua rothrockii   1924         4.278202e-03        1925 #> 14   AZ  SG2    Bouteloua rothrockii   1925         7.640600e-03        1926 #> 15   AZ  SG2    Bouteloua rothrockii   1926         0.000000e+00        1927 #> 16   AZ  SG2   Calliandra eriophylla   1922         4.923767e-05        1923 #> 17   AZ  SG2   Calliandra eriophylla   1923         0.000000e+00        1924 #> 18   AZ  SG2   Calliandra eriophylla   1924         4.923767e-05        1925 #> 19   AZ  SG2   Calliandra eriophylla   1925         7.385650e-05        1926 #> 20   AZ  SG2   Calliandra eriophylla   1926         0.000000e+00        1927 #> 21   AZ  SG4 Ambrosia artemisiifolia   1922         2.461883e-04        1923 #> 22   AZ  SG4 Ambrosia artemisiifolia   1923         0.000000e+00        1924 #> 23   AZ  SG4 Ambrosia artemisiifolia   1924         0.000000e+00        1925 #> 24   AZ  SG4 Ambrosia artemisiifolia   1925         0.000000e+00        1926 #> 25   AZ  SG4 Ambrosia artemisiifolia   1926         0.000000e+00        1927 #> 26   AZ  SG4    Bouteloua rothrockii   1922         2.680527e-03        1923 #> 27   AZ  SG4    Bouteloua rothrockii   1923         2.782187e-03        1924 #> 28   AZ  SG4    Bouteloua rothrockii   1924         2.404456e-03        1925 #> 29   AZ  SG4    Bouteloua rothrockii   1925         2.199422e-03        1926 #> 30   AZ  SG4    Bouteloua rothrockii   1926         0.000000e+00        1927 #> 31   AZ  SG4   Calliandra eriophylla   1922         0.000000e+00        1923 #> 32   AZ  SG4   Calliandra eriophylla   1923         0.000000e+00        1924 #> 33   AZ  SG4   Calliandra eriophylla   1924         7.385650e-05        1925 #> 34   AZ  SG4   Calliandra eriophylla   1925         0.000000e+00        1926 #> 35   AZ  SG4   Calliandra eriophylla   1926         0.000000e+00        1927 #>    absolute_basalArea_tplus1    lambda #> 1               0.000000e+00 0.0000000 #> 2               0.000000e+00        NA #> 3               0.000000e+00        NA #> 4               0.000000e+00        NA #> 5               0.000000e+00        NA #> 6               3.071770e-02 1.0891004 #> 7               2.985456e-02 0.9719008 #> 8               7.084470e-03 0.2372994 #> 9               0.000000e+00 0.0000000 #> 10              0.000000e+00        NA #> 11              4.225758e-03 0.5519654 #> 12              4.278202e-03 1.0124106 #> 13              7.640600e-03 1.7859372 #> 14              0.000000e+00 0.0000000 #> 15              0.000000e+00        NA #> 16              0.000000e+00 0.0000000 #> 17              4.923767e-05       Inf #> 18              7.385650e-05 1.5000000 #> 19              0.000000e+00 0.0000000 #> 20              0.000000e+00        NA #> 21              0.000000e+00 0.0000000 #> 22              0.000000e+00        NA #> 23              0.000000e+00        NA #> 24              0.000000e+00        NA #> 25              0.000000e+00        NA #> 26              2.782187e-03 1.0379256 #> 27              2.404456e-03 0.8642321 #> 28              2.199422e-03 0.9147275 #> 29              0.000000e+00 0.0000000 #> 30              0.000000e+00        NA #> 31              0.000000e+00        NA #> 32              7.385650e-05       Inf #> 33              0.000000e+00 0.0000000 #> 34              0.000000e+00        NA #> 35              0.000000e+00        NA"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"function calculates density individuals around distinct individual mapped dataset. intended use dataset returned trackSpp function, work sf data.frame individual row represents distinct individual (genet) unique year.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"","code":"getNeighbors(   dat,   buff,   method,   compType = \"allSpp\",   output = \"summed\",   trackID = \"trackID\",   species = \"Species\",   quad = \"Quad\",   year = \"Year\",   site = \"Site\",   geometry = \"geometry\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"dat sf data.frame. row must represent unique individual organism unique year. argument can data.frame returned trackSpp function. must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\"), genet identity (default name \"trackID\"), s.f 'geometry' column contains polygon multipolygon data type individual observation. buff numeric value greater equal zero. indicates distance (units spatial data 'dat') around focal individual within want look competitors. buff can data.frame columns \"Species\" \"buff\". data.frame must row unique species present 'dat', species name character string \"Species\" column, numeric value 'buff' column like use species. method character string, either 'count' 'area'. argument determines method used calculate local neighborhood density. 'method' = 'count', number individuals within buffer returned 'neighbors' column. method = 'area', proportion buffer area occupied individuals returned 'neighbors' column. data 'dat' mapped initially points, best use 'method' = 'count'. data mapped polygons representative individual basal area, using 'method' = 'area' likely accurate representation crowding focal individual experiencing. compType character string, either 'allSpp' 'oneSpp'. compType = 'allSpp', local neighborhood density calculated considering individuals around focal individual, regardless species (interspecific competition). compType = 'oneSpp', local neighborhood density calculated considering individuals buffer area species focal individual (intraspecific competition). output character string, either 'summed' 'bySpecies'. default 'summed'. argument important consider using compType = 'allSpp'. output = 'summed', one count/area value returned individual. value total count area neighbors within focal species buffer zone, regardless species. output = 'bySpecies', count area value returned species present buffer zone. example, 15 individuals inside buffer zone. Five species , three species B, 7 species C. output = 'summed', 'neighbors_count' column output data.frame single value '15' row focal individual. However, output = 'bySpecies', row focal individual output data.frame contain named list 'neighbors_count' column looks like one . 'method' = 'area' 'output' = 'bySpecies', similar list returned, 'neighbors_area' column contain areas rather counts.  trackID optional character string argument. Indicates name column 'dat' contains value uniquely identifies individual/genet. unnecessary include value argument column name 'trackID' (default value 'trackID'). species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary include value argument column name \"geometry\" (default 'geometry'). ... arguments passed methods. currently used.","code":"list(\"Species A \"= 5, \"Species B\" = 3, \"Species C\" = 7) ## $`Species A ` ## [1] 5 ##  ## $`Species B` ## [1] 3 ##  ## $`Species C` ## [1] 7"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"function returns data.frame number rows 'dat' columns, additional column columns. method = 'count', column called \"neighbors_count\" added, contains count number individuals within buffer area occupied individuals. method = 'area', two columns added. first called \"nBuff_area\", contains area buffer around focal individual. second called \"neighbors_area\", contains area individuals within buffer zone around focal individual.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"function draws buffer around individual genet distance specified user. either counts number genets within buffer, calculates proportion buffer area occupied individuals. getNeighbors can calculate either interspecific local neighborhood density (focal individual individuals within buffer area) intraspecific local neighborhood density (focal individual individuals species within buffer area).","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getNeighbors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates local neighborhood density around each individual in a\nmapped dataset — getNeighbors","text":"","code":"dat <- grasslandData[grasslandData$Site == c(\"AZ\") &  grasslandData$Species %in% c(\"Bouteloua rothrockii\",  \"Calliandra eriophylla\"),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\"   finalDat <- getNeighbors(dat = outDat,  buff = .15,  method = 'count',  compType = 'oneSpp',  species = \"speciesName\")"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getRecruits.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","title":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","text":"function calculates number new plant recruits species quadrat year. input data must already contain column indicating whether observation classified recruit . recruit status can generated trackSpp function plantTracker, can information collected field. function includes option determines whether ramet clonal species considered individual recruit, entire genet considered single recruit.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getRecruits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","text":"","code":"getRecruits(   dat,   byGenet = TRUE,   species = \"Species\",   quad = \"Quad\",   site = \"Site\",   year = \"Year\",   trackID = \"trackID\",   recruit = \"recruit\",   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getRecruits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","text":"dat sf data.frame row represents unique polygon (either genet ramet) unique site/quadrat/year combination. data.frame returned trackSpp can put directly function. 'dat' must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\"), unique identifier genet (default name 'trackID'), s.f 'geometry' column contains polygon multipolygon data type individual observation. byGenet logical argument. TRUE indicates new genet considered one recruit, even consists multiple ramets. FALSE indicates new ramet considered new recruit, even ramets genet present previous years. species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary include value argument column name \"Species\" (default value 'Species'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary include value argument column name \"Quad\" (default 'Quad'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary include value argument column name \"Site\" (default value 'Site'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary include value argument column name \"Year\" (default 'Year'). trackID optional character string argument. Indicates name column 'dat' contains unique identifiers genet. unnecessary include value argument column name \"trackID\" (default 'trackID') recruit optional character string argument. Indicates name column 'dat' contains information indicating whether row represents data recruit. unnecessary include value argument column name \"recruit\" (default \"recruit\"). ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getRecruits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","text":"function returns table columns site, quadrat, species name, year, number recruits.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/getRecruits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the number of recruits of each species per year in each quadrat — getRecruits","text":"","code":"dat <- grasslandData[grasslandData$Site == c(\"AZ\") &  grasslandData$Species %in% c(\"Bouteloua rothrockii\",  \"Calliandra eriophylla\") &  grasslandData$Year %in% c(1922:1925),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\"  getRecruits(dat = outDat,  byGenet = TRUE,  species = \"speciesName\"  ) #>   Site Quad           speciesName Year recruits #> 1   AZ  SG2  Bouteloua rothrockii 1923       20 #> 2   AZ  SG2  Bouteloua rothrockii 1924        5 #> 3   AZ  SG2  Bouteloua rothrockii 1925       21 #> 4   AZ  SG2 Calliandra eriophylla 1925        1 #> 5   AZ  SG4  Bouteloua rothrockii 1923       19 #> 6   AZ  SG4  Bouteloua rothrockii 1924        5 #> 7   AZ  SG4  Bouteloua rothrockii 1925        8 #> 8   AZ  SG4 Calliandra eriophylla 1924        3"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandData.html","id":null,"dir":"Reference","previous_headings":"","what":"Chart Quadrat Dataset for grassland species in MT and AZ\nAn example dataset that contains data from mapped plant chart quadrats. Each\nrow is an observation of one plant. — grasslandData","title":"Chart Quadrat Dataset for grassland species in MT and AZ\nAn example dataset that contains data from mapped plant chart quadrats. Each\nrow is an observation of one plant. — grasslandData","text":"Chart Quadrat Dataset grassland species MT AZ example dataset contains data mapped plant chart quadrats. row observation one plant.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chart Quadrat Dataset for grassland species in MT and AZ\nAn example dataset that contains data from mapped plant chart quadrats. Each\nrow is an observation of one plant. — grasslandData","text":"","code":"grasslandData"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Chart Quadrat Dataset for grassland species in MT and AZ\nAn example dataset that contains data from mapped plant chart quadrats. Each\nrow is an observation of one plant. — grasslandData","text":"sf data frame 1242 rows 15 variables: Species character string indicating specific epithet observation. ideal formats 1) latin binomial separated space (.e. \"Bouteloua gracilis\"), 2) latin binomial separated underscore (.e. \"Bouteloua_gracilis\"), 3) species code consisting first n' letters element latin binomial (.e. \"BOUGRA\" \"BOGR\"). Whichever format used, must used rows. Clone integer vector. (1) indicates individual clone (genet). (0) indicates individual clone. NA indicates data recorded. Seedling integer vector indicating whether observation seedling (1), (0). data collected many observations, NA column. Stems integer greater 0 indicating many stems present observed plant. data collected many observations, NA column. Basal integer vector. (1) indicates basal area individual mapped. (0) indicates basal area individual mapped (case used assign function.) NA indicates data recorded. Type factor two levels: 'point' 'poly', indicates whether observation originally mapped 'point' 'polygon'. Site character string indicating sampling location observation. dataset, value either: AZ (Santa Rita Experimental Range, Tucson, AZ) MT (Fort Keogh Livestock Range Research Laboratory, Miles City, MT) Quad character string indicating name quadrat plant mapped. Year integer indicating year plant mapped. sp_code_4 character string 4-letter species code observation (first two letters genus name, first two letters species name, capitalized spaces). sp_code_6 character string 6-letter species code observation (first three letters genus name, first three letters species name, capitalized spaces). Area numeric variable indicating basal area m^2 observation. dataset, observations originally mapped points assigned area 2.46e-05 m^2. individuals mapped polygons, value column indicates basal area plant. geometry sf geometry class \"MULTIPOLYGON\" observation. location polygon indicates plant's location 1 m x 1 m square. plant mapped polygon, area polygon indicates basal area plant.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Chart Quadrat Dataset for grassland species in MT and AZ\nAn example dataset that contains data from mapped plant chart quadrats. Each\nrow is an observation of one plant. — grasslandData","text":"http://dx.doi.org/10.1890/11-2200.1 https://doi.org/10.6084/m9.figshare.c.3304113.v1","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandInventory.html","id":null,"dir":"Reference","previous_headings":"","what":"A dataset indicating sampling years for the grasslandData example dataset — grasslandInventory","title":"A dataset indicating sampling years for the grasslandData example dataset — grasslandInventory","text":"dataset indicates years sampling conducted four quadrats included grasslandData example dataset.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandInventory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A dataset indicating sampling years for the grasslandData example dataset — grasslandInventory","text":"","code":"grasslandInventory"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandInventory.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A dataset indicating sampling years for the grasslandData example dataset — grasslandInventory","text":"named list 8 items, named quadrat included grasslandData dataset. C5 integer vector indicating years quadrat C5 mapped. D1 integer vector indicating years quadrat D1 mapped. SG2 integer vector indicating years quadrat SG2 mapped. SG4 integer vector indicating years quadrat SG4 mapped.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/grasslandInventory.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A dataset indicating sampling years for the grasslandData example dataset — grasslandInventory","text":"http://dx.doi.org/10.1890/11-2200.1 https://doi.org/10.6084/m9.figshare.c.3304113.v1","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":null,"dir":"Reference","previous_headings":"","what":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"function assigns unique 'genetID' polygons within user-defined distance one another. ramet still represented single row data, ramets genet 'genetID'.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"","code":"groupByGenet(dat, buffGenet, ...)"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"dat sf object contains polygons grouped. Typically include data one species, one quadrat, one year. intended use, dataset format described grasslandData. function run 'dat' contains 'geometry' data, strongly recommended columns specified grasslandData included. buffGenet numeric argument indicating half maximum distance individual ramets (polygons) function group together one genet. Note argument units used 'dat' argument. example, buffGenet = 0.005 use grasslandData (measurements meters), polygons 0.01 m (1 cm) apart less grouped genet. ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"numeric vector unique genetIDs long number rows 'dat.' element output genetID ith row 'dat'.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"polygons 'grouped,' given number 'genetID' column. assignment made using network analysis group together polygons closest one another. context plantTracker, function designed group ramets (vegetative clones) together one genet (genetically distinct individual). function designed use within assign function (trackSpp function), can used independently.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/groupByGenet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group polygon observations together into a 'genet' based on proximity — groupByGenet","text":"","code":"dat <- grasslandData[grasslandData$Site == \"AZ\" & grasslandData$Quad == \"SG2\" & grasslandData$Species == \"Bouteloua rothrockii\" & grasslandData$Year == 1922,]  groupByGenet(dat = dat, buffGenet = 0.01) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 groupByGenet(dat = dat, buffGenet = 0.1) #>  [1] 1 2 3 4 5 5 5 2 2 6 2"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/plantTracker-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Demographic and Competition Data from Fine-scale Maps — plantTracker-package","title":"Extract Demographic and Competition Data from Fine-scale Maps — plantTracker-package","text":"package contains functions extract plant growth, survival,    competition data repeated, fine-scale maps plant occurence.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/plantTracker-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Demographic and Competition Data from Fine-scale Maps — plantTracker-package","text":"Alice Stears [aut, cre], Jared Studyvin [aut], David Atkins [aut] Maintainer: Alice Stears <alice.e.stears@gmail.com>","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/plantTracker-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Demographic and Competition Data from Fine-scale Maps — plantTracker-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time.","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Tracks genets through time for multiple species and sites — trackSpp","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"function tracks individual plants mapped quadrats time generate demographic dataset includes survival growth individual.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"","code":"trackSpp(   dat,   inv,   dorm,   buff,   buffGenet,   clonal,   species = \"Species\",   site = \"Site\",   quad = \"Quad\",   year = \"Year\",   geometry = \"geometry\",   aggByGenet = TRUE,   printMessages = TRUE,   flagSuspects = FALSE,   shrink = 0.1,   dormSize = 0.05,   ... )"},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"dat sf data.frame format grasslandData. must columns contain unique identification research site (default name \"Site\"), species name (default name \"Species\"), quadrat identifier (default name \"Quad\"), year data collection (default name \"Year\") s.f 'geometry' column contains polygon multipolygon data type individual observation. function add columns called \"basalArea_ramet\", \"trackID\", \"age\", \"size_tplus1\", \"recruit,\" \"nearEdge,\" \"survives_tplus1\", 'dat' contain columns names. inv named list format grasslandInventory. name element list quadrat name 'dat', contents list element numeric vector years quadrat (unique spatial area) sampled. Make sure years quadrat actually sampled, just years data 'dat' argument! argument allows function differentiate years quadrat sampled years just individuals species present quadrat. dorm numeric vector length 1, indicating number years individual species allowed go dormant, .e. absent map considered individual reappears. must integer greater equal 0. dorm can data.frame columns \"Species\" \"dorm\". data.frame must row unique species present 'dat', species name character string \"Species\" column, numeric value greater equal 0 'dorm' column indicates number years species allowed go dormant. buff numeric vector length 1 greater equal zero, indicating far (units spatial values 'dat') polygon can move year year +1 still considered individual. buff can data.frame columns \"Species\" \"buff\". data.frame must row unique species present 'dat', species name character string \"Species\" column, numeric value 'buff' column specifying 'buff' argument species. buffGenet numeric vector length 1 greater equal zero, indicating close (units spatial values 'dat') polygons must one another year grouped genet ('clonal' argument = TRUE). buffGenet can data.frame columns \"Species\" \"buffGenet\". data.frame must row unique species present 'dat', species name character string \"Species\" column, numeric value greater equal 0 'buffGenet' specifying 'buffGenet' argument species. argument passed groupByGenet function, used inside assign function. clonal logical vector length 1, indicating whether species allowed clonal (.e. multiple polygons (ramets) can grouped one individual (genet)). clonal = TRUE, species allowed clonal, clonal = FALSE, species allowed clonal. clonal can data.frame columns \"Species\" \"clonal\". data.frame must row unique species present 'dat', species name character string \"Species\" column, logical value 'clonal' specifying 'clonal' argument species. species optional character string argument. Indicates name column 'dat' contains species name data. unnecessary provide value argument column name \"Species\" (default value 'Species'). site optional character string argument. Indicates name column 'dat' contains site name data. unnecessary provide value argument column name \"Site\" (default value 'Site'). quad optional character string argument. Indicates name column 'dat' contains quadrat name data. unnecessary provide value argument column name \"Quad\" (default 'Quad'). year optional character string argument. Indicates name column 'dat' contains data year sampling. unnecessary provide value argument column name \"Year\" (default 'Year'). geometry optional character string argument. Indicates name column 'dat' contains sf geometry data. unnecessary provide value argument column name \"geometry\" (default 'geometry'). aggByGenet logical argument determines whether output trackSpp() aggregated genet. value TRUE (default), unique trackID (genet) year represented one row output data.frame. prepares dataset demographic analyses. value FALSE, unique trackID year may represented multiple rows data (ramet gets row). Note value TRUE, columns present input data.frame 'dat' dropped. wish happen, can aggregate data.frame genet hand. printMessages logical argument determines whether function returns messages genet aggregation, well messages indicating year last year sampling quadrat year(s) come gap sampling exceeds 'dorm' argument (thus years data 'NA' \"survives_tplus1\" \"size_tplus1\"). printMessages = TRUE (default), messages printed. printMessages = FALSE, messages printed. flagSuspects logical argument length 1, indicating whether observations 'suspect' flagged. default flagSuspects = FALSE. flagSuspects = TRUE, column called 'Suspect' added output data.frame. suspect observations get 'TRUE' 'Suspect' column, non-suspect observations receive 'FALSE'. two ways observation can classified 'suspect'. First, two consecutive observations trackID, basal area observation year t+1 less certain percentage (defined shrink arg.) basal area observation year t, possible observation year t+1 new recruit individual. second way observation can classified 'suspect' small going dormant. unlikely small individual survive dormancy, possible function mistakenly given survival value '1' individual. 'small individual' observation area certain percentile (specified 'dormSize') size distribution f species, generated using size data species 'dat'. shrink single numeric value. value used flagSuspects = TRUE. two consecutive observations trackID, ratio size t+1 size t smaller value shrink, observation year t gets 'TRUE' 'Suspect' column. example, shrink = 0.2, individual tracking function identified 'BOUGRA_1992_5' area 9 cm^2 year t area 1.35 cm^2 year t+1. ratio size t+1 size t 1.35/9 = 0.15, smaller cutoff specified shrink, observation BOUGRA_1992_5' year t gets 'TRUE' 'Suspect' column. default value shrink = 0.10. dormSize single numeric value. value used flagSuspects = TRUE dorm ≥ 1. individual flagged 'suspect' 'goes dormant' size less equal percentile size distribution species designated dormSize. example dormSize = 0.05, individual basal area 0.5 cm^2. 5th percentile distribution size species, made using mean standard deviation observations 'dat' species question, 0.6 cm^2. individual overlaps next year (year t+1), overlap year t+2. However, basal area observation smaller 5th percentile size species, observation year t get 'TRUE' 'Suspect' column. possible tracking function mistakenly assigned '1' survival year t, unlikely individual large enough survive dormancy. default value dormSize = .05. ... arguments passed methods. currently used.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"sf data.frame columns 'dat,' following additional columns: trackID unique value individual genet, consisting 6-letter species code, year individual recruited, unique index number, separated \"_\". age integer indicating age individual year t. Values NA indicate accurate age calculated individual observed either first year sampling year following gap sampling, exact year recruitment known. size_tplus1  size genet year t+1, units 'area' column 'dat'. recruit Boolean integer indicating whether individual new recruit year t (1), existed previous year (0). Values NA indicate individual observed either first year sampling year following gap sampling, possible accurately determine whether new recruit year t. survives_tplus1 Boolean integer indicating whether individual survived (1), died (0) year t+1. basalArea_genet size entire genet year t, units 'area' column 'dat.' 'clonal' argument = FALSE, number identical 'basalArea_ramet' column. basalArea_ramet included 'aggByGenet' = FALSE. size ramet year t, units 'area' column 'dat'. 'clonal' argument = FALSE , number identical 'basalArea_genet' column. nearEdge logical value indicating whether individual within buffer (specified 'buff' argument) edge quadrat.","code":""},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"wrapper function applies assign across multiple species, quadrats, sites. species quadrat, trackSpp() loads spatially referenced data.frame ('dat'), uses groupByGenet function assign genetIDs polygons ('clonal' = TRUE) polygons form genet genetID. buffer distance defined 'buff' applied around genet polygon. , spatial data genet current year (year t) compared individuals next year (year t+1). trackSpp() calculates amount overlapping area polygons year t genet polygons year t+1 genet (using st_intersection). unambiguous overlap 'parent' genet year t 'child' genet year t+1, 'child' gets identifying trackID parent. 'tie,' one parent overlaps child one child overlaps parent, parent-child pair greatest amount overlap receives trackID. Polygons year t+1 parent given new trackIDs identified new recruits. dormancy allowed, polygons year t child polygons get '0' 'survival' column. dormancy allowed, parent polygons without child polygons stored 'ghosts' compared data year t+1+find potential child polygons, ='dorm' argument. detailed description trackSpp() function, see vignette: vignette(\"Using_the_plantTracker_trackSpp_function\", package = \"plantTracker\")","code":""},{"path":[]},{"path":"http://www.astearsresearch.com/package/plantTracker/reference/trackSpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tracks genets through time for multiple species and sites — trackSpp","text":"","code":"dat <- grasslandData[grasslandData$Site == c(\"AZ\") &  grasslandData$Species %in% c(\"Bouteloua rothrockii\",   \"Calliandra eriophylla\"),] names(dat)[1] <- \"speciesName\" inv <- grasslandInventory[unique(dat$Quad)] outDat <- trackSpp(dat = dat,  inv = inv,  dorm = 1,  buff = .05,  buffGenet = 0.005,  clonal = data.frame(\"Species\" = unique(dat$speciesName),  \"clonal\" = c(TRUE,FALSE)),  species = \"speciesName\",  aggByGenet = TRUE  ) #> Site: AZ #> -- Quadrat: SG2 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> -- Quadrat: SG4 #> ---- Species: Bouteloua rothrockii; Calliandra eriophylla #> [1] \"Note: Individuals in year 1927 have a value of 'NA' in the 'survives_tplus1' and 'size_tplus1' columns because 1927 is the last year of sampling in this quadrat.\" #> [1] \"Note: The output data.frame from this function is shorter than your input data.frame because demographic data has been aggregated by genet. Because of this, some columns that were present in your input data.frame may no longer be present. If you don't want the output to be aggregated by genet, include the argument 'aggByGenet == FALSE' in your call to trackSpp().\""}]
